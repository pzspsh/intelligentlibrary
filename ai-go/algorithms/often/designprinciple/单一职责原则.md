### 理解原则
单一职责原则(SRP)：一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

实施
不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则:

类中的代码行数、函数或者属性过多;

类依赖的其他类过多，或者依赖类的其他类过多;

私有方法过多;

比较难给类起一个合适的名字;

类中大量的方法都是集中操作类中的某几个属性。

实例
假设我们要做一个在手机上玩的俄罗斯方块游戏，Game类可以设计如下：

```go
type Game struct {
  x int64
  y int64
}
func (game *Game) Show() {
  fmt.Println(game.x, game.y)
}
func (game *Game) Move() {
  game.x--
  game.y++
}
```
游戏的显示和移动都放在类Game里。后面需求变更了，不但要在手机上显示，还需要再电脑上显示，而且还有两人对战模式，这些更改主要和显示有关。

这时最好将Show和Move拆分到两个函数，这样不但可以复用Move的逻辑，而且今后无论如何更改Show，都不会影响Move所在的类。

但因为一开始Game职责不单一，整个系统中很多位置使用同一个Game变量调用Show和Move，对这些位置的改动和测试是十分浪费时间的。