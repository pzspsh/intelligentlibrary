# Go æ³›å‹ comparable

## **å…³äº Go æ³›å‹çš„å¼€å‘è¿›åº¦**

Go æ˜¯ä¸€é—¨å¼ºç±»å‹è¯­è¨€ï¼Œæ„å‘³ç€ç¨‹åºä¸­çš„æ¯ä¸ªå˜é‡å’Œå€¼éƒ½æœ‰æŸç§ç‰¹å®šçš„ç±»å‹ï¼Œä¾‹å¦‚ intã€string ç­‰ã€‚æ²¡æœ‰æ³›å‹ï¼Œå¾ˆå¤šäººä»¥æ­¤â€œé„™è§†â€Golangã€‚å½“ç„¶ï¼Œä¹Ÿæœ‰äººè§‰å¾—æ ¹æœ¬ä¸éœ€è¦æ³›å‹ã€‚æœ‰æ³›å‹ï¼Œä¸ä»£è¡¨ä½ ä¸€å®šè¦ç”¨ã€‚åœ¨å¤ç”¨ä»£ç ç­‰åœºæ™¯ä¸‹ï¼Œæ³›å‹è¿˜æ˜¯å¾ˆæœ‰å¿…è¦å’Œå¸®åŠ©çš„ã€‚æ¯”å¦‚ï¼š

```go
func Add(a, b int) int
func AddFloat(a, b float64) float64
```

åœ¨æ³›å‹çš„å¸®åŠ©ä¸‹ï¼Œä¸Šé¢ä»£ç å°±å¯ä»¥ç®€åŒ–æˆä¸ºï¼š

```go
func Add[T any](a, b T) T
```

- Add åé¢çš„[T any]ï¼ŒT è¡¨ç¤ºç±»å‹çš„æ ‡è¯†ï¼Œany è¡¨ç¤º T å¯ä»¥æ˜¯ä»»æ„ç±»å‹ã€‚
- aã€b å’Œè¿”å›å€¼çš„ç±»å‹ T å’Œå‰é¢çš„ T æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚
- ä¸ºä»€ä¹ˆç”¨[]ï¼Œè€Œä¸æ˜¯å…¶ä»–è¯­è¨€ä¸­çš„<>ï¼Œå®˜æ–¹æœ‰è¿‡è§£é‡Šï¼Œå¤§æ¦‚å°±æ˜¯<>ä¼šæœ‰æ­§ä¹‰ã€‚æ›¾ç»è®¡åˆ’ä½¿ç”¨() ï¼Œå› ä¸ºå¤ªå®¹æ˜“æ··æ·†ï¼Œæœ€åä½¿ç”¨äº†[]ã€‚

**ä¸€ã€æ³›å‹**

### **ï¼ˆä¸€ï¼‰ä»€ä¹ˆæ˜¯æ³›å‹**

è°ˆæ³›å‹çš„æ¦‚å¿µï¼Œå¯ä»¥ä»å¤šæ€çœ‹èµ·ï¼Œå¤šæ€æ˜¯åŒä¸€å½¢å¼è¡¨ç°å‡ºä¸åŒè¡Œä¸ºçš„ä¸€ç§ç‰¹æ€§ï¼Œåœ¨ç¼–ç¨‹è¯­è¨€ä¸­è¢«åˆ†ä¸ºä¸¤ç±»ï¼Œä¸´æ—¶æ€§å¤šæ€å’Œå‚æ•°åŒ–å¤šæ€ã€‚

**ä¸´æ—¶æ€§å¤šæ€**ï¼ˆAd hoc Polymorphismï¼‰ï¼Œæ ¹æ®å®å‚ç±»å‹è°ƒç”¨ç›¸åº”çš„ç‰ˆæœ¬ï¼Œä»…æ”¯æŒæ•°é‡ååˆ†æœ‰é™çš„è°ƒç”¨ï¼Œä¹Ÿè¢«ç§°ä½œç‰¹è®¾å¤šæ€ï¼Œä¾‹å¦‚å‡½æ•°é‡è½½ã€‚

```go
func Add(a, b int) int { return a+b }
func Add(a, b float64) float64 { return a+b } // æ³¨æ„: Golangä¸­ä¸å…è®¸åŒåå‡½æ•°
Add(1, 2)     // è°ƒç”¨ç¬¬ä¸€ä¸ª
Add(1.0, 2.0) // è°ƒç”¨ç¬¬äºŒä¸ª
Add(â€œ1â€, â€œ2â€) // ç¼–è¯‘æ—¶ä¸æ£€æŸ¥ï¼Œè¿è¡Œæ—¶æ‰¾ä¸åˆ°å®ç°ï¼Œå´©æºƒæˆ–è€…ç¼–è¯‘æ—¶ç›´æ¥ä¸é€šè¿‡
```

**å‚æ•°åŒ–å¤šæ€**ï¼ˆParametric Polymorphismï¼‰ï¼Œæ ¹æ®å®å‚ç”Ÿæˆä¸åŒçš„ç‰ˆæœ¬ï¼Œæ”¯æŒä»»æ„æ•°é‡çš„è°ƒç”¨ï¼Œå³æ³›å‹ï¼Œç®€è¨€ä¹‹ï¼Œå°±æ˜¯æŠŠå…ƒç´ ç±»å‹å˜æˆäº†å‚æ•°ã€‚

```go
func Add(a, b T)  T {  return a+b  }
Add(1, 2)              // ç¼–è¯‘å™¨ç”Ÿæˆ T = int çš„ Add
Add(float64(1.0), 2.0) // ç¼–è¯‘å™¨ç”Ÿæˆ T = float64 çš„ Add
Add("1", "2")          // ç¼–è¯‘å™¨ç”Ÿæˆ T = string çš„ Add
```

### **ï¼ˆäºŒï¼‰æ³›å‹å›°å¢ƒ**

æ³›å‹å’Œå…¶ä»–ç‰¹æ€§ä¸€æ ·ä¸æ˜¯åªæœ‰å¥½å¤„ï¼Œä¸ºç¼–ç¨‹è¯­è¨€åŠ å…¥æ³›å‹ä¼šé‡åˆ°éœ€è¦æƒè¡¡çš„ä¸¤éš¾é—®é¢˜ã€‚è¯­è¨€çš„è®¾è®¡è€…éœ€è¦åœ¨ç¼–ç¨‹æ•ˆç‡ã€ç¼–è¯‘é€Ÿåº¦å’Œè¿è¡Œé€Ÿåº¦ä¸‰è€…è¿›è¡Œæƒè¡¡å’Œé€‰æ‹©ï¼Œç¼–ç¨‹è¯­è¨€è¦é€‰æ‹©ç‰ºç‰²ä¸€ä¸ªè€Œä¿ç•™å¦å¤–ä¸¤ä¸ªã€‚

åœ¨ 2009 å¹´çš„æ—¶å€™ï¼ŒRuss Cox æå‡ºæ¥çš„ä¸€ä¸ªå…³äºæ³›å‹çš„é—®é¢˜å«åšæ³›å‹å›°å¢ƒï¼Œç”¨æ¥æ”¶é›†äººä»¬å¯¹ Golang ä¸­æ³›å‹çš„ä¸€äº›æ„è§å’Œå»ºè®®ï¼Œå¯¹ Golang æ³›å‹è®¾è®¡å½“ä¸­çš„é—®é¢˜è¿›è¡Œè§£é‡Šï¼Œå¹¶è¡¨ç¤ºä»–ä»¬å¹¶ä¸æ€¥äºå»å®ç°æ³›å‹ï¼Œå› ä¸ºè¿˜æ²¡æœ‰æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„å®ç°æ–¹æ¡ˆå»è§£å†³å›°å¢ƒã€‚

è€Œæ³›å‹å›°å¢ƒçš„æœ¬è´¨æ˜¯ï¼Œå…³äºæ³›å‹ï¼Œä½ æƒ³è¦ç¼“æ…¢çš„ç¨‹åºå‘˜ã€ç¼“æ…¢çš„ç¼–è¯‘å™¨å’Œè‡ƒè‚¿çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œè¿˜æ˜¯ç¼“æ…¢çš„æ‰§è¡Œæ—¶é—´ã€‚ç®€å•æ¥è¯´å°±æ˜¯ï¼šè¦ä¹ˆè‹¦äº†ç¨‹åºå‘˜ï¼Œè¦ä¹ˆè‹¦äº†ç¼–ç»å™¨ï¼Œè¦ä¹ˆé™ä½è¿è¡Œæ—¶æ•ˆç‡ã€‚

![718023a6e5f7a2c53a3447ba27edfd47.png](../../../../images/718023a6e5f7a2c53a3447ba27edfd47.png)

ä»¥ Cã€C++å’Œ Java ä¸ºä¾‹ï¼Œå®ƒä»¬åœ¨æ³›å‹çš„è®¾è®¡ä¸Šæœ‰ç€ä¸åŒè€ƒé‡ï¼š

- C è¯­è¨€æ˜¯ç³»ç»Ÿçº§çš„ç¼–ç¨‹è¯­è¨€ï¼Œæ²¡æœ‰æ”¯æŒæ³›å‹ï¼Œæœ¬èº«æä¾›çš„æŠ½è±¡èƒ½åŠ›éå¸¸æœ‰é™ã€‚ç»“æœæ˜¯ç‰ºç‰²äº†ç¨‹åºå‘˜çš„å¼€å‘æ•ˆç‡ï¼Œä¸ Golang ç›®å‰çš„åšæ³•ä¸€æ ·ï¼Œå®ƒä»¬éƒ½éœ€è¦æ‰‹åŠ¨å®ç°ä¸åŒç±»å‹çš„ç›¸åŒé€»è¾‘ã€‚ä½†æ˜¯ä¸å¼•å…¥æ³›å‹çš„å¥½å¤„ä¹Ÿæ˜¾è€Œæ˜“è§ï¼Œé‚£å°±æ˜¯é™ä½äº†ç¼–è¯‘å™¨å®ç°çš„å¤æ‚åº¦ï¼Œä¹Ÿèƒ½ä¿è¯æºä»£ç çš„ç¼–è¯‘é€Ÿåº¦ï¼›

- C++ä¸ C è¯­è¨€çš„é€‰æ‹©å®Œå…¨ä¸åŒï¼Œå®ƒä½¿ç”¨ç¼–è¯‘æœŸé—´ç±»å‹ç‰¹åŒ–å®ç°æ³›å‹ï¼Œæä¾›äº†éå¸¸å¼ºå¤§çš„æŠ½è±¡èƒ½åŠ›ã€‚è™½ç„¶æé«˜äº†ç¨‹åºå‘˜çš„å¼€å‘æ•ˆç‡ï¼Œä¸å†éœ€è¦æ‰‹å†™åŒä¸€é€»è¾‘çš„ç›¸ä¼¼å®ç°ï¼Œä½†æ˜¯ç¼–è¯‘å™¨çš„å®ç°å˜å¾—éå¸¸å¤æ‚ï¼Œæ³›å‹å±•å¼€ä¼šç”Ÿæˆçš„å¤§é‡é‡å¤ä»£ç ä¹Ÿä¼šå¯¼è‡´æœ€ç»ˆçš„äºŒè¿›åˆ¶æ–‡ä»¶è†¨èƒ€å’Œç¼–è¯‘ç¼“æ…¢ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦é“¾æ¥å™¨æ¥è§£å†³ä»£ç é‡å¤çš„é—®é¢˜ï¼›

- Java åœ¨ 1.5 ç‰ˆæœ¬å¼•å…¥äº†æ³›å‹ï¼Œå®ƒçš„æ³›å‹æ˜¯ç”¨ç±»å‹æ“¦é™¤å®ç°çš„ã€‚Java çš„æ³›å‹åªæ˜¯åœ¨ç¼–è¯‘æœŸé—´ç”¨äºæ£€æŸ¥ç±»å‹çš„æ­£ç¡®ï¼Œä¸ºäº†ä¿è¯ä¸æ—§ç‰ˆæœ¬ JVM çš„å…¼å®¹ï¼Œç±»å‹æ“¦é™¤ä¼šåˆ é™¤æ³›å‹çš„ç›¸å…³ä¿¡æ¯ï¼Œå¯¼è‡´å…¶åœ¨è¿è¡Œæ—¶ä¸å¯ç”¨ã€‚ç¼–è¯‘å™¨ä¼šæ’å…¥é¢å¤–çš„ç±»å‹è½¬æ¢æŒ‡ä»¤ï¼Œä¸ C è¯­è¨€å’Œ C++åœ¨è¿è¡Œå‰å°±å·²ç»å®ç°æˆ–è€…ç”Ÿæˆä»£ç ç›¸æ¯”ï¼ŒJava ç±»å‹çš„è£…ç®±å’Œæ‹†ç®±ä¼šé™ä½ç¨‹åºçš„æ‰§è¡Œæ•ˆç‡

è€Œ Cã€C++å’Œ Java ç›¸æ¯”ï¼ŒGolang æ—¨åœ¨ä½œä¸ºä¸€ç§ç¼–å†™æœåŠ¡å™¨ç¨‹åºçš„è¯­è¨€ï¼Œè¿™äº›ç¨‹åºéšç€æ—¶é—´çš„æ¨ç§»æ˜“äºç»´æŠ¤ï¼Œä¾§é‡äºå¯ä¼¸ç¼©æ€§ã€å¯è¯»æ€§å’Œå¹¶å‘æ€§ç­‰å¤šç§æ–¹é¢ã€‚æ³›å‹ç¼–ç¨‹åœ¨å½“æ—¶ä¼¼ä¹å¯¹ Golang çš„ç›®æ ‡å¹¶ä¸é‡è¦ï¼Œå› æ­¤ä¸ºäº†ç®€å•èµ·è§è¢«æ’é™¤åœ¨å¤–ã€‚

### **ï¼ˆä¸‰ï¼‰å®ç°æ³›å‹çš„æ–¹å¼**

![15b736aa4903d13cf2ba944dbfc88b94.png](../../../../images/15b736aa4903d13cf2ba944dbfc88b94.png)

ä¾‹å¦‚ä¸‹é¢æ˜¯ä¸€ä½ç¨‹åºçŒ¿è‡ªå·±å†™çš„ä¸€ä¸ªå®ç°ç±»ä¼¼æ³›å‹çš„ä»£ç ï¼š

![2f35ce32965a4857e157e6cbc56a675e.gif](../../../../images/2f35ce32965a4857e157e6cbc56a675e.gif)

**äºŒã€Golang ä¸­çš„æ³›å‹**

## **ï¼ˆä¸€ï¼‰å…³äº Go æ³›å‹çš„å¼€å‘è¿›åº¦**

Go æ˜¯ä¸€é—¨å¼ºç±»å‹è¯­è¨€ï¼Œæ„å‘³ç€ç¨‹åºä¸­çš„æ¯ä¸ªå˜é‡å’Œå€¼éƒ½æœ‰æŸç§ç‰¹å®šçš„ç±»å‹ï¼Œä¾‹å¦‚ intã€string ç­‰ã€‚æ²¡æœ‰æ³›å‹ï¼Œå¾ˆå¤šäººä»¥æ­¤â€œé„™è§†â€Golangã€‚å½“ç„¶ï¼Œä¹Ÿæœ‰äººè§‰å¾—æ ¹æœ¬ä¸éœ€è¦æ³›å‹ã€‚æœ‰æ³›å‹ï¼Œä¸ä»£è¡¨ä½ ä¸€å®šè¦ç”¨ã€‚åœ¨å¤ç”¨ä»£ç ç­‰åœºæ™¯ä¸‹ï¼Œæ³›å‹è¿˜æ˜¯å¾ˆæœ‰å¿…è¦å’Œå¸®åŠ©çš„ã€‚æ¯”å¦‚ï¼š

```swift
func Add(a, b int) int
func AddFloat(a, b float64) float64
```

åœ¨æ³›å‹çš„å¸®åŠ©ä¸‹ï¼Œä¸Šé¢ä»£ç å°±å¯ä»¥ç®€åŒ–æˆä¸ºï¼š

```markdown
func Add[T any](a, b T) T
```

- Add åé¢çš„[T any]ï¼ŒT è¡¨ç¤ºç±»å‹çš„æ ‡è¯†ï¼Œany è¡¨ç¤º T å¯ä»¥æ˜¯ä»»æ„ç±»å‹ã€‚

- aã€b å’Œè¿”å›å€¼çš„ç±»å‹ T å’Œå‰é¢çš„ T æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚

- ä¸ºä»€ä¹ˆç”¨[]ï¼Œè€Œä¸æ˜¯å…¶ä»–è¯­è¨€ä¸­çš„<>ï¼Œå®˜æ–¹æœ‰è¿‡è§£é‡Šï¼Œå¤§æ¦‚å°±æ˜¯<>ä¼šæœ‰æ­§ä¹‰ã€‚æ›¾ç»è®¡åˆ’ä½¿ç”¨() ï¼Œå› ä¸ºå¤ªå®¹æ˜“æ··æ·†ï¼Œæœ€åä½¿ç”¨äº†[]ã€‚

Golang å›¢é˜Ÿä¸€ç›´åœ¨å°è¯•æ³›å‹çš„è®¾è®¡ï¼Œä¹‹å‰ä¹Ÿæœ‰å¾ˆå¤šçš„åŠªåŠ›å’Œå°è¯•ï¼ŒåŒ…æ‹¬å„ç§æ³›å‹ææ¡ˆå’Œå®ç°æ–¹å¼ï¼Œä½†æœ€åéƒ½è¢«å¦å†³äº†ã€‚Golang æ ¸å¿ƒä½œè€…ç»™å‡ºçš„è§£é‡Šæ˜¯æ³›å‹å¹¶ä¸æ˜¯ä¸å¯æˆ–ç¼ºçš„ç‰¹æ€§ï¼Œå±äºé‡è¦ä½†ä¸ç´§æ€¥ï¼Œåº”è¯¥æŠŠç²¾åŠ›é›†ä¸­åœ¨æ›´é‡è¦çš„äº‹æƒ…ä¸Šï¼Œä¾‹å¦‚ GC çš„å»¶è¿Ÿä¼˜åŒ–ï¼Œç¼–è¯‘å™¨è‡ªä¸¾ç­‰ã€‚ç°åœ¨ä»–ä»¬è®¤ä¸º Goalng ç°åœ¨æ›´åŠ æˆç†Ÿäº†ï¼ŒåŠ ä¸Šç›®å‰æ³›å‹æ˜¯ Golang ç¤¾åŒºå‘¼å£°æœ€é«˜çš„ï¼Œå¸Œæœ›è¢«å°½å¿«å®ç°çš„è¯­è¨€ç‰¹æ€§ï¼Œå› æ­¤ï¼Œå¯ä»¥è€ƒè™‘æŸç§å½¢å¼çš„æ³›å‹ç¼–ç¨‹ã€‚

ç›®å‰ï¼Œåœ¨ 1.17 çš„ç‰ˆæœ¬ä¸­ Golang ç»ˆäºæ¨å‡ºæ¥æ³›å‹çš„å°é²œç‰ˆäº†ï¼Œå®˜æ–¹ç›®å‰é¢„è®¡æ­¤æ›´æ”¹å°†åœ¨ 2022 å¹´åˆçš„ Go1.18 ç‰ˆæœ¬ä¸­å¯ç”¨ï¼ˆWe currently expect that this change will be available in the Go1.18 release in early 2022.ï¼‰ã€‚è€Œæ³›å‹ï¼Œæ˜¯ Golang å¤šå¹´æ¥æœ€ä»¤äººå…´å¥‹å’Œæ ¹æœ¬æ€§çš„å˜åŒ–ä¹‹ä¸€ã€‚

### **ï¼ˆäºŒï¼‰Golang1.17 ä¸­æ³›å‹çš„è¦ç‚¹**

- å‡½æ•°å¯ä»¥é€šè¿‡ type å…³é”®å­—å¼•å…¥é¢å¤–çš„ç±»å‹å‚æ•°(type parameters)åˆ—è¡¨ï¼šfunc F(type T)(p T) { ... } ã€‚

- è¿™äº›ç±»å‹å‚æ•°å¯ä»¥åƒä¸€èˆ¬çš„å‚æ•°ä¸€æ ·åœ¨å‡½æ•°ä½“ä¸­ä½¿ç”¨ã€‚

- ç±»å‹ä¹Ÿå¯ä»¥æ‹¥æœ‰ç±»å‹å‚æ•°åˆ—è¡¨ï¼štype M(type T) []Tã€‚

- æ¯ä¸ªç±»å‹å‚æ•°å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªçº¦æŸï¼šfunc F(type T Constraint)(p T) { ... }ã€‚

- ä½¿ç”¨ interface æ¥æè¿°ç±»å‹çš„çº¦æŸã€‚

- è¢«ç”¨ä½œç±»å‹çº¦æŸçš„ interface å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªé¢„å£°æ˜ç±»å‹åˆ—è¡¨ï¼Œé™åˆ¶äº†å®ç°æ­¤æ¥å£çš„ç±»å‹çš„åŸºç¡€ç±»å‹ã€‚

- ä½¿ç”¨æ³›å‹å‡½æ•°æˆ–ç±»å‹æ—¶éœ€è¦ä¼ å…¥ç±»å‹å®å‚ã€‚

- ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œç±»å‹æ¨æ–­å…è®¸ç”¨æˆ·åœ¨è°ƒç”¨æ³›å‹å‡½æ•°æ—¶çœç•¥ç±»å‹å®å‚ã€‚

- å¦‚æœç±»å‹å‚æ•°å…·æœ‰ç±»å‹çº¦æŸï¼Œåˆ™ç±»å‹å®å‚å¿…é¡»å®ç°æ¥å£ã€‚

- æ³›å‹å‡½æ•°åªå…è®¸è¿›è¡Œç±»å‹çº¦æŸæ‰€è§„å®šçš„æ“ä½œã€‚

###

### **ï¼ˆä¸‰ï¼‰å¦‚ä½•ä½¿ç”¨**

- å¯ä»¥ç›´æ¥åœ¨https://go2goplay.golang.org/è¿›è¡Œæµ‹è¯•ä½¿ç”¨ã€‚

- åœ¨ docker ä¸­è£…ä¸ª 1.17 çš„ç‰ˆæœ¬ï¼Œè¿è¡Œæ—¶ç”¨ go run-gcflags=-G=3~/main.go å‘½ä»¤å°±å¥½äº†ã€‚

**ä¸‰ã€Golang æ³›å‹æ¡ˆä¾‹**

### **ï¼ˆä¸€ï¼‰å¦‚ä½•å¯¹æ³›å‹è¿›è¡Œè¾“å‡º**

ä¸‹é¢çš„ä¾‹å­æ˜¯ä¸€ä¸ªå¯¹æ³›å‹è¾“å‡ºçš„åŸºæœ¬ä¾‹å­ã€‚å‡½æ•°å¯ä»¥æœ‰ä¸€ä¸ªé¢å¤–çš„ç±»å‹å‚æ•°åˆ—è¡¨ï¼Œå®ƒä½¿ç”¨æ–¹æ‹¬å·ï¼Œä½†çœ‹èµ·æ¥åƒä¸€ä¸ªæ™®é€šçš„å‚æ•°åˆ—è¡¨ï¼šfunc F[T any](p T) { ... }ï¼Œä»£ç ä¸­çš„[T any]å³ä¸ºç±»å‹å‚æ•°ï¼Œæ„æ€æ˜¯è¯¥å‡½æ•°æ”¯æŒä»»ä½• T ç±»å‹ï¼Œå½“æˆ‘ä»¬è°ƒç”¨ printSlice[string]([]string{â€œHelloâ€ï¼Œâ€œWorldâ€})æ—¶ï¼Œä¼šè¢«ç±»å‹æ¨å¯¼ä¸º string ç±»å‹ï¼Œä¸è¿‡åœ¨ç¼–è¯‘å™¨å®Œå…¨å¯ä»¥å®ç°ç±»å‹æ¨å¯¼æ—¶ï¼Œä¹Ÿå¯ä»¥çœç•¥æ˜¾å¼ç±»å‹ï¼Œå¦‚ï¼šprintSlice([]string{â€œHelloâ€ï¼Œâ€œWorldâ€}) ï¼Œè¿™æ ·ä¹Ÿå°†ä¼šæ˜¯å¯¹çš„ï¼›

```go
package main

import (
    "fmt"
)

func printSlice[T any](s []T) {
    for _, v := range s {
        fmt.Printf("%v ", v)
    }
    fmt.Print("\n")
}

func main() {
    printSlice[int]([]int{1, 2, 3, 4, 5})
    printSlice[float64]([]float64{1.01, 2.02, 3.03, 4.04, 5.05})
    printSlice([]string{"Hello", "World"})
    printSlice[int64]([]int64{5, 4, 3, 2, 1})
}

è¾“å‡ºä¸ºï¼š
1 2 3 4 5
1.01 2.02 3.03 4.04 5.05
Hello World
5 4 3 2 1
```

### **ï¼ˆäºŒï¼‰å¦‚ä½•ç”¨æ³›å‹çº¦æŸä½¿ç”¨çš„ç±»å‹èŒƒå›´**

è¿™ä¸ªä¾‹å­åŒ…å«äº†ä¸€ä¸ª**ç±»å‹çº¦æŸ**ã€‚æ¯ä¸ªç±»å‹å‚æ•°éƒ½æœ‰ä¸€ä¸ªç±»å‹çº¦æŸï¼Œå°±åƒæ¯ä¸ªæ™®é€šå‚æ•°éƒ½æœ‰ä¸€ä¸ªç±»å‹ï¼šfunc F[T Constraint](p T) { ... }ï¼Œç±»å‹çº¦æŸæ˜¯æ¥å£ç±»å‹ã€‚è¯¥ææ¡ˆæ‰©å±•äº† interface è¯­æ³•ï¼Œæ–°å¢äº†ç±»å‹åˆ—è¡¨(type list)è¡¨è¾¾æ–¹å¼ï¼Œä¸“ç”¨äºå¯¹ç±»å‹å‚æ•°è¿›è¡Œçº¦æŸã€‚

```go
package main

import (
    "fmt"
)

type Addable interface {
    type int, int8, int16, int32, int64,
    uint, uint8, uint16, uint32, uint64, uintptr,
    float32, float64, complex64, complex128,
    string
}

func add[T Addable] (a, b T) T {
    return a + b
}

func main() {
    fmt.Println(add(1,2))
    fmt.Println(add("hello","world"))
}

è¾“å‡ºä¸ºï¼š
3
helloworld
```

åœ¨å®˜æ–¹çš„æœ€æ–° proposal é‡Œæœ‰æåˆ°ï¼Œåœ¨ Golang ä¸­ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„ç±»å‹éƒ½æ»¡è¶³+å·è¿ç®—ã€‚åœ¨ 1.17 çš„ç‰ˆæœ¬ä¸­ï¼Œæ³›å‹å‡½æ•°åªèƒ½ä½¿ç”¨ç±»å‹å‚æ•°æ‰€èƒ½å®ä¾‹åŒ–å‡ºçš„ä»»æ„ç±»å‹éƒ½èƒ½æ”¯æŒçš„æ“ä½œã€‚

æ¯”å¦‚ä¸‹é¢çš„ add å‡½æ•°çš„ç±»å‹å‚æ•° T æ²¡æœ‰ä»»ä½•çº¦æŸï¼Œå®ƒå¯ä»¥è¢«å®ä¾‹åŒ–ä¸ºä»»ä½•ç±»å‹ï¼›é‚£ä¹ˆè¿™äº›å®ä¾‹åŒ–åçš„ç±»å‹æ˜¯å¦éƒ½æ”¯æŒ+æ“ä½œç¬¦è¿ç®—å‘¢ï¼Ÿæ˜¾ç„¶ä¸æ˜¯ï¼›å› æ­¤ï¼ŒæŠ¥é”™äº†ï¼å¯¹äºæ²¡æœ‰ä»»ä½•çº¦æŸçš„ç±»å‹å‚æ•°å®ä¾‹ï¼Œå…è®¸å¯¹å…¶è¿›è¡Œçš„æ“ä½œåŒ…æ‹¬ï¼š

- å£°æ˜è¿™äº›ç±»å‹çš„å˜é‡ã€‚
- ä½¿ç”¨ç›¸åŒç±»å‹çš„å€¼ä¸ºè¿™äº›å˜é‡èµ‹å€¼ã€‚
- å°†è¿™äº›ç±»å‹çš„å˜é‡ä»¥å®å‚å½¢å¼ä¼ ç»™å‡½æ•°æˆ–ä»ä½œä¸ºå‡½æ•°è¿”å›å€¼ã€‚
- å–è¿™äº›å˜é‡çš„åœ°å€ã€‚
- å°†è¿™äº›ç±»å‹çš„å€¼è½¬æ¢æˆ–èµ‹å€¼ç»™ interface{}ç±»å‹å˜é‡ã€‚
- é€šè¿‡ç±»å‹æ–­è¨€å°†ä¸€ä¸ªæ¥å£å€¼èµ‹å€¼ç»™è¿™ç±»ç±»å‹çš„å˜é‡ã€‚
- åœ¨ type switch å—ä¸­ä½œä¸ºä¸€ä¸ª case åˆ†æ”¯ã€‚
- å®šä¹‰å’Œä½¿ç”¨ç”±è¯¥ç±»å‹ç»„æˆçš„å¤åˆç±»å‹ï¼Œæ¯”å¦‚ï¼šå…ƒç´ ç±»å‹ä¸ºè¯¥ç±»å‹çš„åˆ‡ç‰‡ã€‚
- å°†è¯¥ç±»å‹ä¼ é€’ç»™ä¸€äº›å†…ç½®å‡½æ•°ï¼Œæ¯”å¦‚ newã€‚

è¿™å°±æ„å‘³ç€ï¼Œå¦‚æœä¸ç”¨ interface çº¦æŸï¼Œç›´æ¥ä½¿ç”¨çš„è¯ï¼Œä½ è®²å¾—åˆ°å¦‚ä¸‹çš„ç»“æœï¼š

```go
package main

import (
    "fmt"
)

func add[T any] (a, b T) T {
    return a + b
}

func main() {
    fmt.Println(add(1,2))
    fmt.Println(add("hello","world"))
}

è¾“å‡ºï¼š
type checking failed for main
prog.go2:8:9: invalid operation: operator + not defined for a (variable of type parameter type T)
```

åœ¨çº¦æŸé‡Œï¼Œç”šè‡³å¯ä»¥æ”¾è¿›å»æ¥å£å¦‚ä¸‹ï¼š

```go
package main

import (
    "fmt"
)

type Addable interface {
    type int,interface{}
}


func add[T Addable] (a T) T {
    return a
}

func main() {
    fmt.Println(add(1))
}
```

æ¥ç€å‡å¦‚æˆ‘ä»¬å»æ‰ stringï¼Œå¦‚ä¸‹ä»£ç æ‰€ç¤ºã€‚ä»¥è¯¥ç¤ºä¾‹ä¸ºä¾‹ï¼Œå¦‚æœç¼–è¯‘å™¨é€šè¿‡ç±»å‹æ¨å¯¼å¾—åˆ°çš„ç±»å‹ä¸åœ¨è¿™ä¸ªæ¥å£å®šä¹‰çš„ç±»å‹çº¦æŸåˆ—è¡¨ä¸­ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å°†å…è®¸è¿™ä¸ªç±»å‹å‚æ•°å®ä¾‹åŒ–ï¼›å¦åˆ™å°±åƒç±»å‹å‚æ•°å®ä¾‹åŒ–å°†æŠ¥é”™ï¼

```go
package main

import (
    "fmt"
)

type Addable interface {
    type int, int8, int16, int32, int64,
    uint, uint8, uint16, uint32, uint64, uintptr,
    float32, float64, complex64, complex128
}


func add[T Addable] (a, b T) T {
    return a + b
}

func main() {
    fmt.Println(add(1,2))
    fmt.Println(add("hello","world"))
}

è¾“å‡ºä¸ºï¼š
type checking failed for main
prog.go2:19:14: string does not satisfy Addable (string or string not found in int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64, complex64, complex128)
```

**æ³¨æ„**ï¼šæˆ‘ä»¬è‡ªå·±å®šä¹‰çš„å¸¦æœ‰ç±»å‹åˆ—è¡¨çš„æ¥å£å°†æ— æ³•ç”¨ä½œæ¥å£å˜é‡ç±»å‹ï¼Œå¦‚ä¸‹ä»£ç å°†ä¼šæŠ¥é”™

```go
package main

type MyType interface {
    type int
}

func main() {
    var n int = 6
    var i MyType
    i = n
    _ = i
}

è¾“å‡ºä¸ºï¼š
type checking failed for main
prog.go2:9:8: interface contains type constraints (int)
```

### **ï¼ˆä¸‰ï¼‰æ³›å‹ä¸­çš„æ¥å£æœ¬èº«å¯¹èŒƒå‹è¿›è¡Œçº¦æŸ**

```go
package main

import (
  "fmt"
  "strconv"
)

type MyStringer interface {
    String() string
}

type StringInt int

type myString string

func (i StringInt) String() string {
    return strconv.Itoa(int(i))
}

func (str myString) String() string {
    return string(str)
}

func stringify[T MyStringer](s []T) (ret []string) {
    for _, v := range s {
        ret = append(ret, v.String())
    }
    return ret
}

func stringify2[T MyStringer](s []T) (ret []string) {
    for _, v := range s {
        ret = append(ret, v.String())
    }
    return ret
}

func main() {
    fmt.Println(stringify([]StringInt{1, 2, 3, 4, 5}))
    fmt.Println(stringify2([]myString{"1", "2", "3", "4", "5"}))
}

è¾“å‡ºä¸ºï¼š
[1 2 3 4 5]
[1 2 3 4 5]
```

ä»£ç ä¸­æˆ‘ä»¬å£°æ˜äº† MyStringer æ¥å£ï¼Œå¹¶ä¸”ä½¿ç”¨ StringInt å’Œ myString ç±»å‹å®ç°äº†æ­¤æ¥å£ï¼›åœ¨èŒƒå‹æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å£°æ˜äº†èŒƒå‹çš„ç±»å‹ä¸ºï¼šä»»æ„å®ç°äº† MyStringer æ¥å£çš„ç±»å‹ï¼›åªè¦å®ç°äº†è¿™ä¸ªæ¥å£ï¼Œé‚£ä¹ˆä½ å°±å¯ä»¥ç›´æ¥ä½¿ç”¨ï¼Œåœ¨ç°åœ¨æŸäº›éœ€è¦ä¼  interface{}ä½œä¸ºå‚æ•°çš„å‡½æ•°é‡Œé¢ï¼Œå¯ä»¥ç›´æ¥æŒ‡å®šç±»å‹äº†ã€‚å½“ä½ æ”¹ä¸ºå¦‚ä¸‹ä»£ç æ—¶

```go
func main() {
    fmt.Println(Stringify([]int{1, 2, 3, 4, 5}))
}
```

ä¼šæŠ¥é”™ï¼š

```cpp
è¾“å‡ºä¸ºï¼š
type checking failed for main
prog.go2:27:14: int does not satisfy MyStringer (missing method String)
```

åªæœ‰å®ç°äº† Stringer æ¥å£çš„ç±»å‹æ‰ä¼šè¢«å…è®¸ä½œä¸ºå®å‚ä¼ é€’ç»™ Stringify æ³›å‹å‡½æ•°çš„ç±»å‹å‚æ•°å¹¶æˆåŠŸå®ä¾‹åŒ–ï¼å½“ç„¶ä¹Ÿå¯ä»¥å°† MyStringer æ¥å£å†™æˆå¦‚ä¸‹çš„å½¢å¼ï¼š

```go
type MySignedStringer interface {
    type int, int8, int16, int32, int64
    String() string
}
```

è¡¨ç¤ºåªæœ‰ int, int8, int16, int32, int64ï¼Œè¿™æ ·ç±»å‹å‚æ•°çš„å®å‚ç±»å‹æ—¢è¦åœ¨ MySignedStringer çš„ç±»å‹åˆ—è¡¨ä¸­ï¼Œä¹Ÿè¦å®ç°äº† MySignedStringer çš„ String æ–¹æ³•ï¼Œæ‰èƒ½ä½¿ç”¨ã€‚åƒè¿™ç§ä¸åœ¨é‡Œé¢çš„ type StringInt uint å°±ä¼šæŠ¥é”™ã€‚

### **ï¼ˆå››ï¼‰æ³›å‹ä¸­å¦‚ä½•æ“ä½œåˆ‡ç‰‡**

å¯ä»¥çœ‹åˆ°åœ¨ä¸‹é¢çš„ä¾‹å­é‡Œé¢ï¼Œæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªå¯ä»¥å­˜æ”¾ä»»ä½•ç±»å‹çš„åˆ‡ç‰‡ï¼Œå«åš sliceï¼Œå¦‚ type slice[T any] []Tã€‚å’Œæ³›å‹å‡½æ•°ä¸€æ ·ï¼Œä½¿ç”¨æ³›å‹ç±»å‹æ—¶ï¼Œé¦–å…ˆè¦å¯¹å…¶è¿›è¡Œå®ä¾‹åŒ–ï¼Œå³æ˜¾å¼ä¸º**ç±»å‹å‚æ•°**èµ‹å€¼ç±»å‹ã€‚å¦‚æœåœ¨ç±»å‹å®šä¹‰æ—¶ï¼Œå°†ä»£ç æ”¹æˆ vs:=slice{5,4,2,1}ï¼Œé‚£ä¹ˆä½ ä¼šå¾—åˆ°å¦‚ note1 ä¸­çš„ç»“æœã€‚å› ä¸ºç¼–è¯‘å™¨å¹¶æ²¡æœ‰åŠæ³•è¿›è¡Œç±»å‹æ¨å¯¼ï¼Œä¹Ÿå°±æ˜¯è¡¨ç¤ºå®ƒå¹¶ä¸çŸ¥é“ï¼Œä½ è¾“å‡ºçš„æ˜¯é‚£ç§ç±»å‹ã€‚å“ªæ€•ä½ åœ¨ interface é‡Œé¢å®šä¹‰äº†çº¦æŸã€‚å“ªæ€•ä½ åœ¨æ¥å£ä¸­å®šä¹‰äº†ç±»å‹çº¦æŸ type int, stringï¼ŒåŒæ ·ä¼šæŠ¥é”™ï¼Œå¦‚ note2 æ‰€ç¤ºã€‚

```go
package main

import (
    "fmt"
)

type slice[T any] []T

/*
type any interface {
  type int, string
}*/

func printSlice[T any](s []T) {
    for _, v := range s {
        fmt.Printf("%v ", v)
    }
    fmt.Print("\n")
}

func main() {
    // note1: cannot use generic type slice[T interface{}] without instantiation
    // note2: cannot use generic type slice[T any] without instantiation
    vs := slice[int]{5, 4, 2, 1}
    printSlice(vs)
    vs2 := slice[string]{"hello", "world"}
    printSlice(vs2)
}

è¾“å‡ºä¸ºï¼š
5 4 2 1
hello world
```

### **ï¼ˆäº”ï¼‰å¦‚ä½•åˆ©ç”¨æ³›å‹å®ç°æœ€å¤§å€¼æœ€å°å€¼å‡½æ•°**

```go
package main

import (
    "fmt"
)

type minmax interface {
    type int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr, float32, float64
}

func max[T minmax](a []T) T {
    m := a[0]
    for _, v := range a {
        if m < v {
            m = v
        }
    }
    return m
}

func min[T minmax](a []T) T {
    m := a[0]
    for _, v := range a {
        if m > v {
            m = v
        }
    }
    return m
}

func main() {
    vi := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    result := max(vi)
    fmt.Println(result)
    vi = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    result = min(vi)
    fmt.Println(result)
}

è¾“å‡ºä¸ºï¼š
10
1
```

### **ï¼ˆå…­ï¼‰å¦‚ä½•ä½¿ç”¨ Golang æ³›å‹è‡ªå¸¦çš„ comparable çº¦æŸ**

å½“ä½ å†™æˆå¦‚ä¸‹ä»£ç æ—¶ï¼Œä¾¿ä¼šæŠ¥é”™ï¼š

```go
package main

import (
  "fmt"
)

func findFunc[T any](a []T, v T) int {
  for i, e := range a {
    if e == v {
      return i
    }
  }
  return -1
}

func main() {
  fmt.Println(findFunc([]int{1, 2, 3, 4, 5, 6}, 5))
}

è¾“å‡ºä¸ºï¼š
type checking failed for main
prog.go2:9:6: cannot compare e == v (operator == not defined for T)
```

å› ä¸ºä¸æ˜¯æ‰€æœ‰çš„ç±»å‹éƒ½å¯ä»¥==æ¯”è¾ƒï¼Œæ‰€ä»¥ Golang å†…ç½®æä¾›äº†ä¸€ä¸ª comparable çº¦æŸï¼Œè¡¨ç¤ºå¯æ¯”è¾ƒçš„ã€‚å‚è€ƒä¸‹é¢ä»£ç ï¼š

```go
package main

import (
    "fmt"
)

func findFunc[T comparable](a []T, v T) int {
    for i, e := range a {
        if e == v {
            return i
        }
    }
    return -1
}


func main() {
    fmt.Println(findFunc([]int{1, 2, 3, 4, 5, 6}, 5))
}

è¾“å‡ºä¸ºï¼š
4
```

### **ï¼ˆä¸ƒï¼‰å¦‚ä½•åœ¨æ³›å‹ä¸­æ“ä½œæŒ‡é’ˆ**

```go
package main

import (
    "fmt"
)


func pointerOf[T any](v T) *T {
    return &v
}

func main() {
    sp := pointerOf("foo")
    fmt.Println(*sp)
    ip := pointerOf(123)
    fmt.Println(*ip)
    *ip = 234
    fmt.Println(*ip)
}

è¾“å‡ºä¸ºï¼š
foo
123
234
```

### **ï¼ˆå…«ï¼‰Golang æ³›å‹ä¸­å¦‚ä½•æ“ä½œ map**

åœ¨ç°å®å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦å¯¹ slice ä¸­æ•°æ®çš„æ¯ä¸ªå€¼è¿›è¡Œå•ç‹¬çš„å¤„ç†ï¼Œæ¯”å¦‚è¯´éœ€è¦å¯¹å…¶ä¸­æ•°å€¼è½¬æ¢ä¸ºå¹³æ–¹å€¼ï¼Œåœ¨æ³›å‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŠ½å–éƒ¨åˆ†é‡å¤é€»è¾‘ä½œä¸º map å‡½æ•°ï¼š

```go
package main

import (
    "fmt"
)

func mapFunc[T any, M any](a []T, f func(T) M) []M {
    n := make([]M, len(a), cap(a))
    for i, e := range a {
        n[i] = f(e)
    }
    return n
}

func main() {
    vi := []int{1, 2, 3, 4, 5, 6}
    vs := mapFunc(vi, func(v int) string {
        return "<" + fmt.Sprint(v*v) + ">"
    })
    fmt.Println(vs)
}

è¾“å‡ºä¸ºï¼š
[<1> <4> <9> <16> <25> <36>]
```

### **ï¼ˆä¹ï¼‰å¦‚ä½•åœ¨ Golang æ³›å‹ä¸­ä½¿ç”¨é˜Ÿåˆ—æ“ä½œ**

åœ¨ç°å®å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æœ‰å¯èƒ½ä¼šéœ€è¦ä¸€ä¸ªé˜Ÿåˆ—å»å¤„ç†ä¸€äº›æ•°æ®ï¼Œåœ¨æ³›å‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æŠ½å–éƒ¨åˆ†é‡å¤é€»è¾‘æ¥å®ç°

```go
package main

import (
    "fmt"
)

type queue[T any] []T

func (q *queue[T]) enqueue(v T) {
    *q = append(*q, v)
}


func (q *queue[T]) dequeue() (T, bool) {
    if len(*q) == 0 {
        var zero T
        return zero, false
    }
    r := (*q)[0]
    *q = (*q)[1:]
    return r, true
}

func main() {
    q := new(queue[int])
    q.enqueue(5)
    q.enqueue(6)
    fmt.Println(q)
    fmt.Println(q.dequeue())
    fmt.Println(q.dequeue())
    fmt.Println(q.dequeue())
}
è¾“å‡ºä¸ºï¼š
&amp;[5 6]
5 true
6 true
0 false
```

### **ï¼ˆåï¼‰Golang æ³›å‹ä¸­æ–°åŠ å…¥çš„ä¸€äº›çº¦æŸåŒ…**

å®˜æ–¹ä¹Ÿå¼•å…¥äº†ä¸€äº›å®˜æ–¹åŒ…æ¥æ–¹é¢æ³›å‹çš„ä½¿ç”¨ï¼Œå…·ä½“å¦‚ä¸‹ï¼š

```typescript
// constraints å®šä¹‰äº†ä¸€ç»„ä¸ç±»å‹å‚æ•°ä¸€èµ·ä½¿ç”¨çš„çº¦æŸ
package constraints

// Signedæ˜¯å…è®¸ä»»ä½•æœ‰ç¬¦å·æ•´æ•°ç±»å‹çš„çº¦æŸã€‚
type Signed interface { ... }

// Unsignedæ˜¯å…è®¸ä»»ä½•æ— ç¬¦å·æ•´æ•°ç±»å‹çš„çº¦æŸã€‚
type Unsigned interface { ... }

// Integeræ˜¯å…è®¸ä»»ä½•æ•´æ•°ç±»å‹çš„çº¦æŸã€‚
type Integer interface { ... }

// Floatæ˜¯ä¸€ä¸ªå…è®¸ä»»ä½•æµ®ç‚¹ç±»å‹çš„çº¦æŸã€‚
type Float interface { ... }

// Complexæ˜¯å…è®¸ä»»ä½•å¤æ‚æ•°å€¼ç±»å‹çš„çº¦æŸã€‚
type Complex interface { ... }

// Orderedæ˜¯ä¸€ä¸ªçº¦æŸï¼Œå…è®¸ä»»ä½•æœ‰åºç±»å‹:ä»»ä½•æ”¯æŒæ“ä½œç¬¦< <= >= >çš„ç±»å‹ã€‚
type Ordered interface { ... }
```

ä½¿ç”¨æ–¹å¼ç¤ºä¾‹å¦‚ä¸‹ï¼š

```go
package main

import (
    "constraints"
    "fmt"
)


type v[T constraints.Ordered] T

type Vector[T constraints.Ordered] struct {
    x, y T
}

func (v *Vector[T]) Add(x, y T) {
    v.x += T(x)
    v.y += T(y)
}


func (v *Vector[T]) String() string {
    return fmt.Sprintf("{x: %v, y: %v}", v.x, v.y)
}

func NewVector[T constraints.Ordered](x, y T) *Vector[T] {
    return &amp;Vector[T]{x: x, y: y}
}

func main() {
    v := NewVector[float64](1, 2)
    v.Add(2, 3)
    fmt.Println(v)
}
```

**å››ã€æ€»ç»“**

å°½ç®¡æœ€æ–°çš„ proposal å†—é•¿è€Œè¯¦å°½ï¼Œä½†æ€»ç»“èµ·æ¥å¦‚ä¸‹ï¼š

- å‡½æ•°å’Œç±»å‹å¯ä»¥å…·æœ‰ç±»å‹å‚æ•°ï¼Œè¯¥ç±»å‹å‚æ•°ä½¿ç”¨å¯é€‰çº¦æŸï¼ˆæ¥å£ç±»å‹ï¼‰å®šä¹‰ï¼Œçº¦æŸæè¿°äº†è¿™äº›å‚æ•°æ‰€éœ€çš„æ–¹æ³•å’Œå…è®¸çš„ç±»å‹ã€‚

- å½“ä½¿ç”¨ç±»å‹å‚æ•°è°ƒç”¨å‡½æ•°æ—¶ï¼Œç±»å‹æ¨æ–­é€šå¸¸ä¼šå…è®¸ç”¨æˆ·çœç•¥ç±»å‹å‚æ•°ã€‚

- æ³›å‹å‡½æ•°åªèƒ½ä½¿ç”¨çº¦æŸå…è®¸çš„æ‰€æœ‰ç±»å‹æ”¯æŒçš„æ“ä½œ

- æ­¤è®¾è®¡å®Œå…¨å‘åå…¼å®¹ï¼Œä½†å»ºè®®å¯¹ func F(x(T))çš„å«ä¹‰è¿›è¡Œæ›´æ”¹ã€‚

### **ï¼ˆä¸€ï¼‰é€‚ç”¨æ€§**

æ­¤å¤–ï¼Œæ ‡å‡†åº“ä¸­å°†ä¼šå¼•å…¥ä¸€ç³»åˆ—æ–°çš„ packageã€‚

- ä¸€ä¸ªæ–° slices åŒ…å°†ä¼šè¢«å¼•å…¥ï¼Œå®ƒä¸ç°å­˜çš„ bytes å’Œ strings åŒ…ç±»ä¼¼ï¼Œç”¨äºæ“ä½œä»»ä½•ç±»å‹å…ƒç´ çš„ sliceã€‚æ–°çš„ maps å’Œ chans åŒ…å°†ä¼šæä¾›ä¸€äº›ç®€å•çš„ç®—æ³•ï¼Œç”¨äºæ“ä½œä»»æ„ç±»å‹çš„å…ƒç´ ã€‚set åŒ…ä¹Ÿä¼šè¢«å¼•å…¥ã€‚

- ä¸€ä¸ªæ–° constraints åŒ…å°†ä¼šæä¾›ä¸€ç³»åˆ—æ ‡å‡†çº¦æŸï¼Œå¦‚â€œæ‰€æœ‰æ•´æ•°ç±»å‹â€æˆ–â€œæ‰€æœ‰æ•°å€¼ç±»å‹â€è¿™ç±»çº¦æŸã€‚

- è¯¸å¦‚ container/listï¼Œcontainer/ring è¿™äº›åŒ…ï¼Œæˆ–è€…æ˜¯è¯¸å¦‚ sync.Mapï¼Œsync/atomic.Value ä¹‹ç±»ï¼Œå°†ä¼šå‡çº§åˆ°ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨ï¼ˆä½¿ç”¨æ–°çš„åå­—æˆ–æ–°çš„ç‰ˆæœ¬ ï¼‰ã€‚

- math åŒ…å°†ä¼šä¸ºæ•°å€¼ç±»å‹æä¾›ä¸€ç³»åˆ—ç®€å•çš„æ ‡å‡†ç®—æ³•ï¼Œæ¯”å¦‚å‘¼å£°å¾ˆé«˜çš„ Min å’Œ Max å‡½æ•°ã€‚

- å¯èƒ½ä¼šå¼€å‘æ–°çš„ç‰¹æ®Šå®¹å™¨ï¼Œè¿™äº›å®¹å™¨æ˜¯ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨çš„ï¼Œä¹Ÿå¯èƒ½ä¼šå¢åŠ æ³›å‹çš„ sort åŒ…ã€‚

### **ï¼ˆäºŒï¼‰å¤æ‚æ€§**

Golang çš„ä¸€å¤§ä¼˜ç‚¹æ˜¯å®ƒçš„ç®€å•æ€§ã€‚æ˜¾ç„¶ï¼Œè¿™ç§è®¾è®¡ä½¿è¯­è¨€æ›´åŠ å¤æ‚ï¼Œå¯¹äºæ³›å‹æ¨å‡ºï¼Œæ— è®ºé‡‡ç”¨ä»€ä¹ˆæŠ€æœ¯ï¼Œéƒ½ä¼šå¢åŠ  Golang çš„å¤æ‚æ€§ï¼Œæå‡å…¶å­¦ä¹ é—¨æ§›ï¼Œä»£ç çš„å¯è¯»æ€§ä¹Ÿå¯èƒ½ä¼šä¸‹é™ï¼Œå®˜æ–¹å¯¹å…¶å¢åŠ çš„å¤æ‚æ€§çš„è§£é‡Šå¦‚ä¸‹ï¼š

- å¯¹äºé˜…è¯»ç¼–å†™è‰¯å¥½çš„é€šç”¨ä»£ç è€Œä¸æ˜¯ç¼–å†™ä»£ç çš„äººæ¥è¯´ï¼Œå¢åŠ çš„å¤æ‚æ€§å¾ˆå°ã€‚

- é¢„è®¡å¤§å¤šæ•°åŒ…ä¸ä¼šå®šä¹‰æ³›å‹ç±»å‹æˆ–å‡½æ•°ï¼Œä½†è®¸å¤šåŒ…å¯èƒ½ä¼šä½¿ç”¨å…¶ä»–åœ°æ–¹å®šä¹‰çš„æ³›å‹ç±»å‹æˆ–å‡½æ•°ã€‚

- åœ¨å¸¸è§æƒ…å†µä¸‹ï¼Œæ³›å‹å‡½æ•°çš„å·¥ä½œæ–¹å¼ä¸éæ³›å‹å‡½æ•°å®Œå…¨ç›¸åŒã€‚

### **ï¼ˆä¸‰ï¼‰æ•ˆç‡**

å®˜æ–¹ç›®å‰å°šä¸æ¸…æ¥šäººä»¬æœŸæœ›ä»é€šç”¨ä»£ç ä¸­è·å¾—ä»€ä¹ˆæ ·çš„æ•ˆç‡ï¼Œä»–ä»¬å°†å…¶åˆ’åˆ†ä¸ºæ³›å‹å‡½æ•°å’Œæ³›å‹ç±»å‹ã€‚

- å¯ä»¥ä½¿ç”¨åŸºäºæ¥å£çš„æ–¹æ³•ç¼–è¯‘æ³›å‹å‡½æ•°ã€‚è¿™å°†ä¼˜åŒ–ç¼–è¯‘æ—¶é—´ï¼Œå› ä¸ºå‡½æ•°åªç¼–è¯‘ä¸€æ¬¡ï¼Œä½†ä¼šæœ‰ä¸€äº›è¿è¡Œæ—¶é—´æˆæœ¬ã€‚

- å¯¹äºæ¯ç»„ç±»å‹å‚æ•°ï¼Œæ³›å‹ç±»å‹å¯èƒ½è¢«ç¼–è¯‘å¤šæ¬¡ã€‚è¿™æ˜¾ç„¶ä¼šå¸¦æ¥ç¼–è¯‘æ—¶é—´æˆæœ¬ï¼Œä½†ä¸åº”è¯¥æœ‰ä»»ä½•è¿è¡Œæ—¶é—´æˆæœ¬ã€‚ç¼–è¯‘å™¨è¿˜å¯ä»¥é€‰æ‹©ä½¿ç”¨ç±»ä¼¼äºæ¥å£ç±»å‹çš„æ–¹æ³•æ¥å®ç°æ³›å‹ç±»å‹ï¼Œä½¿ç”¨ä¸“ç”¨æ–¹æ³•è®¿é—®ä¾èµ–äºç±»å‹å‚æ•°çš„æ¯ä¸ªå…ƒç´ ã€‚

### **ï¼ˆå››ï¼‰æ¸©é¦¨æç¤º**

1.17 ç‰ˆæœ¬çš„ Golangï¼Œæ³›å‹ç©ç©å°±è¡Œï¼Œä¸è¦ç”¨åˆ°ç”Ÿäº§ä¸­ã€‚

**äº”ã€Golang æ³›å‹çš„å‘å±•å†å²**

### **ï¼ˆä¸€ï¼‰Type Functions (2010) by Ian Lance Taylor**

```go
type Lesser(t) interface {
    Less(t) bool
}

func Min(a, b t type Lesser(t)) t {
    if a.Less(b) {
        return a
    }
    return b
}
```

**å…³é”®è®¾è®¡**

- åœ¨æ ‡è¯†ç¬¦åä½¿ç”¨(t)ä½œä¸ºç±»å‹å‚æ•°çš„ç¼ºçœå€¼ï¼Œè¯­æ³•å­˜åœ¨äºŒä¹‰æ€§ã€‚

- æ—¢å¯ä»¥è¡¨ç¤ºä½¿ç”¨ç±»å‹å‚æ•° Greater(t)ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºå®ä¾‹åŒ–ä¸€ä¸ªå…·ä½“ç±»å‹ Greater(t)ï¼Œå…¶ä¸­ t ä¸ºæ¨å¯¼çš„å…·ä½“ç±»å‹ï¼Œå¦‚ intã€‚

- ä¸ºäº†è§£å†³äºŒä¹‰æ€§ï¼Œä½¿ç”¨ type è¿›è¡Œé™å®šï¼šVector(t type)func F(arg0, arg1 t type) t { â€¦ }

- ä½¿ç”¨æ¥å£ Greater(t) å¯¹ç±»å‹å‚æ•°è¿›è¡Œçº¦æŸï¼Œè·Ÿåœ¨ type åä¿®é¥°ã€‚

ææ¡ˆè¿˜åŒ…å«ä¸€äº›å…¶ä»–çš„å¤‡é€‰è¯­æ³•ï¼š

```php
generic(t) func ..
$t // ä½¿ç”¨ç±»å‹å‚æ•°
t  // å®ä¾‹åŒ–å…·ä½“ç±»å‹
```

**è¯„è¿°**

- ç¡®å®æ˜¯ä¸€ä¸ªç³Ÿç³•çš„è®¾è®¡ã€‚

- x:= Vector(t)(v0) è¿™æ˜¯ä¸¤ä¸ªå‡½æ•°è°ƒç”¨å—ï¼Ÿ

- å°è¯•å€Ÿç”¨ä½¿ç”¨ C++çš„ Concepts å¯¹ç±»å‹å‚æ•°çš„çº¦æŸã€‚

### **ï¼ˆäºŒï¼‰Generalized Types (2011) by Ian Lance Taylor**

```go
gen [T] type Greater interface {
    IsGreaterThan(T) bool
}

gen [T Greater[T]] func Max(arg0, arg1 T) T {
    if arg0.IsGreaterThan(arg1) {
        return arg0
    }
    return arg1
}

gen [T1, T2] (
    type Pair struct { first T1; second T2 }
    func MakePair(first T1, second T2) Pair {
        return &amp;Pair{first, second}
    })
```

**å…³é”®è®¾è®¡**

- ä½¿ç”¨ gen [T]æ¥å£°æ˜ä¸€ä¸ªç±»å‹å‚æ•°

- ä½¿ç”¨æ¥å£å¯¹ç±»å‹è¿›è¡Œçº¦æŸ

- ä½¿ç”¨ gen [T] ( â€¦ )æ¥å¤ç”¨ç±»å‹å‚æ•°çš„åç§°

**è¯„è¿°**

- æ²¡æœ‰è„±ç¦»ç³Ÿç³•è®¾è®¡çš„å‘½è¿ã€‚

- gen [T] ( â€¦ )å¼•å…¥äº†ä½œç”¨åŸŸçš„æ¦‚å¿µ éœ€è¦ç¼©è¿›å—ï¼Ÿ

- é™¤äº†æ³¨é‡Šè¿˜æœ‰æ›´å¥½çš„æ–¹å¼å¿«é€Ÿå®šä½ä½œç”¨åŸŸçš„ç»“æŸå—ï¼Ÿ

- å¤æ‚çš„ç±»å‹å‚æ•°å£°æ˜ã€‚

### **ï¼ˆä¸‰ï¼‰Type Parameters (Dec. 2013) by Ian Lance Taylor**

```go
type [T] Greater interface {
    IsGreaterThan(T) bool
}

func [T] Max(arg0, arg1 T) T {
    if arg0.IsGreaterThan(arg1) {
        return arg0
    }
    return arg1
}

type Int int

func (i Int) IsGreaterThan(j Int) bool {
    return i > j
}

func F() {
    _ = Max(0, Int(1)) // æ¨å¯¼ä¸º Int
}
```

**å…³é”®è®¾è®¡**

- ç›´æ¥åœ¨ç±»å‹ã€æ¥å£ã€å‡½æ•°åå‰ä½¿ç”¨ [T] è¡¨ç¤ºç±»å‹å‚æ•°

- è¿›ä¸€æ­¥ç»†åŒ–äº†ç±»å‹æ¨å¯¼ä½œä¸ºçº¦æŸçš„å¯èƒ½æ€§

**è¯„è¿°**

- ç›®å‰ä¸ºæ­¢æœ€å¥½çš„è®¾è®¡

- æ— æ˜¾å¼ç±»å‹å‚æ•°çš„ç±»å‹æ¨å¯¼éå¸¸å¤æ‚

- å¸¸é‡ç©¶ç«Ÿåº”è¯¥è¢«æ¨å¯¼ä¸ºä»€ä¹ˆç±»å‹ï¼Ÿ

- [T] çš„ä½ç½®å¾ˆè¯¡å¼‚ï¼Œå£°æ˜åœ¨å·¦ï¼Œä½¿ç”¨åœ¨å³ï¼Œä¾‹å¦‚ï¼štype[T1, T2]Pair struct{ â€¦ }ã€varvPair[T1, T2]

### **ï¼ˆäº”ï¼‰go:generate (2014) by Rob Pike**

```swift
import "github.com/cheekybits/genny/generic"**

// cat 201401.go | genny gen "T=NUMBERS" > 201401_gen.go**

type T generic.Type

func MaxT(fn func(a, b T) bool, a, b T) T {**
    if fn(a, b) {
        return a
     }
     return b
}
```

**å…³é”®è®¾è®¡**

- é€šè¿‡//go:generate ç¼–è¯‘å™¨æŒ‡ç¤ºæ¥è‡ªåŠ¨ç”Ÿæˆä»£ç 

- åˆ©ç”¨è¿™ä¸€ç‰¹æ€§æ¯”è¾ƒä¼˜ç§€çš„å®ç°æ˜¯ cheekybits/gennyï¼ˆhttps://github.com/cheekybits/gennyï¼‰

**è¯„è¿°**

- ç»´æŠ¤æˆæœ¬

- éœ€è¦é‡æ–°ç”Ÿæˆä»£ç 

- æ²¡æœ‰ç±»å‹æ£€æŸ¥ï¼Œéœ€è¦ç¨‹åºå‘˜è‡ªè¡Œåˆ¤æ–­

### **ï¼ˆå…­ï¼‰First Class Types (2015) by Bryan C. Mills**

```go
const func AsWriterTo(reader gotype) gotype {
    switch reader.(type) {
    case io.WriterTo:
        return reader
    default:
        type WriterTo struct {
            reader
        }
        func (t *WriterTo) WriteTo(w io.Writer) (n int64, err error) {
            return io.Copy(w, t.reader)
            }
        return WriterTo (type)
    }
}


const func MakeWriterTo(reader gotype) func(reader) AsWriterTo(reader) {
    switch reader.(type) {
        case io.WriterTo:
        return func(r reader) AsWriterTo(reader) {
            return r
        }
        default:
        return func(r reader) AsWriterTo(reader) {
            return AsWriterTo(reader) { r }
        }
    }
}
```

**å…³é”®è®¾è®¡**

- å¼•å…¥ gotype å†…å»ºç±»å‹

- æ‰©å±•(type)çš„ç¼–è¯‘æœŸç‰¹æ€§

- const å‰ç¼€å¼ºåŒ–å‡½æ•°çš„ç¼–è¯‘æœŸç‰¹æ€§

- çµæ„Ÿæ¥æº C++SFINAE

**è¯„è¿°**

- è®¾è®¡ä¸Šéœ€è¦é¢å¤–æ€è€ƒ SFINAE

- åªæœ‰æ³›å‹å‡½æ•°çš„æ”¯æŒï¼Œæ³›å‹ç»“æ„éœ€è¦é€šè¿‡å‡½æ•°æ¥æ„é€ 

- ä¸å¤ªå¯èƒ½å®ç°å¯ç±»å‹æ¨å¯¼

### **ï¼ˆä¸ƒï¼‰Contracts (2018) by Ian Lance Taylor and Robert Griesemer**

```go
contract comparable(x T) {
       x == x
}

func Contains(type T comparable)(s []T, e T) bool {
    for _, v := range s {
        if v == e { // now valid
            return true
        }
    }
    return false
}
```

åˆçº¦æ˜¯ä¸€ä¸ªæè¿°äº†ä¸€ç»„ç±»å‹ä¸”ä¸ä¼šè¢«æ‰§è¡Œçš„å‡½æ•°ä½“ã€‚

**å…³é”®è®¾è®¡**

- åœ¨åˆçº¦ä¸­å†™ Go è¯­å¥å¯¹ç±»å‹è¿›è¡Œä¿éšœ

- ç”šè‡³å†™å‡ºæ¡ä»¶ã€å¾ªç¯ã€èµ‹å€¼è¯­å¥

**è¯„è¿°**

- å¤æ‚çš„åˆçº¦å†™æ³•ï¼ˆåˆçº¦å†…çš„ä»£ç å†™æ³•å¯ä»¥æœ‰å¤šå°‘ç§ï¼Ÿï¼‰

- ã€Œä¸€ä¸ªä¸ä¼šæ‰§è¡Œçš„å‡½æ•°ä½“ã€å¤ªå…·è¿·æƒ‘æ€§ å®ç°ä¸Šä¼°è®¡æ˜¯ä¸€ä¸ªæ¯”è¾ƒéº»çƒ¦çš„é—®é¢˜

### **ï¼ˆå…«ï¼‰Contracts (2019) by Ian Lance Taylor and Robert Griesemer**

```go
contract Ordered(T) {
    T int, int8, int16, int32, int64,
    uint, uint8, uint16, uint32, uint64, uintptr,
    float32, float64,
    string
}

func Min (type T Ordered) (a, b T) T {
    if a < b {
        return a
    }
    return b
}
```

åˆçº¦æè¿°äº†ä¸€ç»„ç±»å‹çš„å¿…è¦æ¡ä»¶ã€‚

**å…³é”®è®¾è®¡**

- ä½¿ç”¨æ–¹æ³•åŠç©·ä¸¾ç±»å‹æ¥é™åˆ¶å¹¶æè¿°å¯èƒ½çš„å‚æ•°ç±»å‹

- comparable/arithmetic ç­‰å†…å»ºåˆçº¦

# 1. ä¸€åˆ‡ä»å‡½æ•°çš„å½¢å‚å’Œå®å‚è¯´èµ·

å‡è®¾æˆ‘ä»¬æœ‰ä¸ªè®¡ç®—ä¸¤æ•°ä¹‹å’Œçš„å‡½æ•°

```go
func Add(a int, b int) int {
    return a + b
}
```

è¿™ä¸ªå‡½æ•°å¾ˆç®€å•ï¼Œä½†æ˜¯å®ƒæœ‰ä¸ªé—®é¢˜â€”â€”æ— æ³•è®¡ç®— int ç±»å‹ä¹‹å¤–çš„å’Œã€‚å¦‚æœæˆ‘ä»¬æƒ³è®¡ç®—æµ®ç‚¹æˆ–è€…å­—ç¬¦ä¸²çš„å’Œè¯¥æ€ä¹ˆåŠï¼Ÿè§£å†³åŠæ³•ä¹‹ä¸€å°±æ˜¯åƒä¸‹é¢è¿™æ ·ä¸ºä¸åŒç±»å‹å®šä¹‰ä¸åŒçš„å‡½æ•°

```go
func AddFloat32(a float32, b float32) float32 {
    return a + b
}

func AddString(a string, b string) string {
    return a + b
}
```

å¯æ˜¯é™¤æ­¤ä¹‹å¤–è¿˜æœ‰æ²¡æœ‰æ›´å¥½çš„æ–¹æ³•ï¼Ÿç­”æ¡ˆæ˜¯æœ‰çš„ï¼Œæˆ‘ä»¬å¯ä»¥æ¥å›é¡¾ä¸‹å‡½æ•°çš„ **å½¢å‚(parameter)** å’Œ **å®å‚(argument)** è¿™ä¸€åŸºæœ¬æ¦‚å¿µï¼š

```go
func Add(a int, b int) int {
    // å˜é‡a,bæ˜¯å‡½æ•°çš„å½¢å‚   "a int, b int" è¿™ä¸€ä¸²è¢«ç§°ä¸ºå½¢å‚åˆ—è¡¨
    return a + b
}

Add(100,200) // è°ƒç”¨å‡½æ•°æ—¶ï¼Œä¼ å…¥çš„100å’Œ200æ˜¯å®å‚
```

æˆ‘ä»¬çŸ¥é“ï¼Œå‡½æ•°çš„ **å½¢å‚(parameter)** åªæ˜¯ç±»ä¼¼å ä½ç¬¦çš„ä¸œè¥¿å¹¶æ²¡æœ‰å…·ä½“çš„å€¼ï¼Œåªæœ‰æˆ‘ä»¬è°ƒç”¨å‡½æ•°ä¼ å…¥**å®å‚(argument)** ä¹‹åæ‰æœ‰å…·ä½“çš„å€¼ã€‚

é‚£ä¹ˆï¼Œå¦‚æœæˆ‘ä»¬å°† **å½¢å‚ å®å‚** è¿™ä¸ªæ¦‚å¿µæ¨å¹¿ä¸€ä¸‹ï¼Œç»™å˜é‡çš„ç±»å‹ä¹Ÿå¼•å…¥å’Œç±»ä¼¼å½¢å‚å®å‚çš„æ¦‚å¿µçš„è¯ï¼Œé—®é¢˜å°±è¿åˆƒè€Œè§£ï¼šåœ¨è¿™é‡Œæˆ‘ä»¬å°†å…¶ç§°ä¹‹ä¸º **ç±»å‹å½¢å‚(type parameter)** å’Œ **ç±»å‹å®å‚(type argument)**ï¼Œå¦‚ä¸‹ï¼š

```go
// å‡è®¾ T æ˜¯ç±»å‹å½¢å‚ï¼Œåœ¨å®šä¹‰å‡½æ•°æ—¶å®ƒçš„ç±»å‹æ˜¯ä¸ç¡®å®šçš„ï¼Œç±»ä¼¼å ä½ç¬¦
func Add(a T, b T) T {
    return a + b
}
```

åœ¨ä¸Šé¢è¿™æ®µä¼ªä»£ç ä¸­ï¼Œ T è¢«ç§°ä¸º **ç±»å‹å½¢å‚(type parameter)**ï¼Œ å®ƒä¸æ˜¯å…·ä½“çš„ç±»å‹ï¼Œåœ¨å®šä¹‰å‡½æ•°æ—¶ç±»å‹å¹¶ä¸ç¡®å®šã€‚å› ä¸º T çš„ç±»å‹å¹¶ä¸ç¡®å®šï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åƒå‡½æ•°çš„å½¢å‚é‚£æ ·ï¼Œåœ¨è°ƒç”¨å‡½æ•°çš„æ—¶å€™å†ä¼ å…¥å…·ä½“çš„ç±»å‹ã€‚è¿™æ ·æˆ‘ä»¬ä¸å°±èƒ½ä¸€ä¸ªå‡½æ•°åŒæ—¶æ”¯æŒå¤šä¸ªä¸åŒçš„ç±»å‹äº†å—ï¼Ÿåœ¨è¿™é‡Œè¢«ä¼ å…¥çš„å…·ä½“ç±»å‹è¢«ç§°ä¸º **ç±»å‹å®å‚(type argument)**:

ä¸‹é¢ä¸€æ®µä¼ªä»£ç å±•ç¤ºäº†è°ƒç”¨å‡½æ•°æ—¶ä¼ å…¥ç±»å‹å®å‚çš„æ–¹å¼ï¼š

```go
// [T=int]ä¸­çš„ int æ˜¯ç±»å‹å®å‚ï¼Œä»£è¡¨ç€å‡½æ•°Add()å®šä¹‰ä¸­çš„ç±»å‹å½¢å‚ T å…¨éƒ½è¢« int æ›¿æ¢
Add[T=int](100, 200)
// ä¼ å…¥ç±»å‹å®å‚intåï¼ŒAdd()å‡½æ•°çš„å®šä¹‰å¯è¿‘ä¼¼çœ‹æˆä¸‹é¢è¿™æ ·ï¼š
func Add( a int, b int) int {
    return a + b
}

// å¦ä¸€ä¸ªä¾‹å­ï¼šå½“æˆ‘ä»¬æƒ³è¦è®¡ç®—ä¸¤ä¸ªå­—ç¬¦ä¸²ä¹‹å’Œçš„æ—¶å€™ï¼Œå°±ä¼ å…¥stringç±»å‹å®å‚
Add[T=string]("Hello", "World")
// ç±»å‹å®å‚stringä¼ å…¥åï¼ŒAdd()å‡½æ•°çš„å®šä¹‰å¯è¿‘ä¼¼è§†ä¸ºå¦‚ä¸‹
func Add( a string, b string) string {
    return a + b
}
```

é€šè¿‡å¼•å…¥ **ç±»å‹å½¢å‚** å’Œ **ç±»å‹å®å‚** è¿™ä¸¤ä¸ªæ¦‚å¿µï¼Œæˆ‘ä»¬è®©ä¸€ä¸ªå‡½æ•°è·å¾—äº†å¤„ç†å¤šç§ä¸åŒç±»å‹æ•°æ®çš„èƒ½åŠ›ï¼Œè¿™ç§ç¼–ç¨‹æ–¹å¼è¢«ç§°ä¸º **æ³›å‹ç¼–ç¨‹**ã€‚

å¯èƒ½ä½ ä¼šå·²å¥‡æ€ªï¼Œæˆ‘é€šè¿‡ Go çš„ æ¥å£+åå°„ ä¸ä¹Ÿèƒ½å®ç°è¿™æ ·çš„åŠ¨æ€æ•°æ®å¤„ç†å—ï¼Ÿæ˜¯çš„ï¼Œæ³›å‹èƒ½å®ç°çš„åŠŸèƒ½é€šè¿‡æ¥å£+åå°„ä¹ŸåŸºæœ¬èƒ½å®ç°ã€‚ä½†æ˜¯ä½¿ç”¨è¿‡åå°„çš„äººéƒ½çŸ¥é“åå°„æœºåˆ¶æœ‰å¾ˆå¤šé—®é¢˜ï¼š

1. ç”¨èµ·æ¥éº»çƒ¦
2. å¤±å»äº†ç¼–è¯‘æ—¶çš„ç±»å‹æ£€æŸ¥ï¼Œä¸ä»”ç»†å†™å®¹æ˜“å‡ºé”™
3. æ€§èƒ½ä¸å¤ªç†æƒ³

è€Œåœ¨æ³›å‹é€‚ç”¨çš„æ—¶å€™ï¼Œå®ƒèƒ½è§£å†³ä¸Šé¢è¿™äº›é—®é¢˜ã€‚ä½†è¿™ä¹Ÿä¸æ„å‘³ç€æ³›å‹æ˜¯ä¸‡é‡‘æ²¹ï¼Œæ³›å‹æœ‰ç€è‡ªå·±çš„é€‚ç”¨åœºæ™¯ï¼Œå½“ä½ ç–‘æƒ‘æ˜¯ä¸æ˜¯è¯¥ç”¨æ³›å‹çš„è¯ï¼Œè¯·è®°ä½ä¸‹é¢è¿™æ¡ç»éªŒï¼š

> å¦‚æœä½ ç»å¸¸è¦åˆ†åˆ«ä¸ºä¸åŒçš„ç±»å‹å†™å®Œå…¨ç›¸åŒé€»è¾‘çš„ä»£ç ï¼Œé‚£ä¹ˆä½¿ç”¨æ³›å‹å°†æ˜¯æœ€åˆé€‚çš„é€‰æ‹©

# 2. Go çš„æ³›å‹

é€šè¿‡ä¸Šé¢çš„ä¼ªä»£ç ï¼Œæˆ‘ä»¬å®é™…ä¸Šå·²ç»å¯¹ Go çš„æ³›å‹ç¼–ç¨‹æœ‰äº†æœ€åˆæ­¥ä¹Ÿæ˜¯æœ€é‡è¦çš„è®¤è¯†â€”â€” ç±»å‹å½¢å‚ å’Œ ç±»å‹å®å‚ã€‚è€Œ Go1.18 ä¹Ÿæ˜¯é€šè¿‡è¿™ç§æ–¹å¼å®ç°çš„æ³›å‹ï¼Œä½†æ˜¯å•çº¯çš„å½¢å‚å®å‚æ˜¯è¿œè¿œä¸èƒ½å®ç°æ³›å‹ç¼–ç¨‹çš„ï¼Œæ‰€ä»¥ Go è¿˜å¼•å…¥äº†éå¸¸å¤šå…¨æ–°çš„æ¦‚å¿µï¼š

- ç±»å‹å½¢å‚ (Type parameter)
- ç±»å‹å®å‚(Type argument)
- ç±»å‹å½¢å‚åˆ—è¡¨( Type parameter list)
- ç±»å‹çº¦æŸ(Type constraint)
- å®ä¾‹åŒ–(Instantiations)
- æ³›å‹ç±»å‹(Generic type)
- æ³›å‹æ¥æ”¶å™¨(Generic receiver)
- æ³›å‹å‡½æ•°(Generic function)

ç­‰ç­‰ç­‰ç­‰ã€‚

å•Šï¼Œå®åœ¨æ¦‚å¿µå¤ªå¤šäº†å¤´æ™•ï¼Ÿæ²¡äº‹è¯·è·Ÿç€æˆ‘æ…¢æ…¢æ¥ï¼Œé¦–å…ˆä» **æ³›å‹ç±»å‹(generic type)** è®²èµ·

# 3. ç±»å‹å½¢å‚ã€ç±»å‹å®å‚ã€ç±»å‹çº¦æŸå’Œæ³›å‹ç±»å‹

è§‚å¯Ÿä¸‹é¢è¿™ä¸ªç®€å•çš„ä¾‹å­ï¼š

```go
type IntSlice []int

var a IntSlice = []int{1, 2, 3} // æ­£ç¡®
var b IntSlice = []float32{1.0, 2.0, 3.0} // âœ— é”™è¯¯ï¼Œå› ä¸ºIntSliceçš„åº•å±‚ç±»å‹æ˜¯[]intï¼Œæµ®ç‚¹ç±»å‹çš„åˆ‡ç‰‡æ— æ³•èµ‹å€¼
```

è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªæ–°çš„ç±»å‹ `IntSlice` ï¼Œå®ƒçš„åº•å±‚ç±»å‹æ˜¯ `[]int` ï¼Œç†æ‰€å½“ç„¶åªæœ‰ int ç±»å‹çš„åˆ‡ç‰‡èƒ½èµ‹å€¼ç»™ `IntSlice` ç±»å‹çš„å˜é‡ã€‚

æ¥ä¸‹æ¥å¦‚æœæˆ‘ä»¬æƒ³è¦å®šä¹‰ä¸€ä¸ªå¯ä»¥å®¹çº³ `float32` æˆ– `string` ç­‰å…¶ä»–ç±»å‹çš„åˆ‡ç‰‡çš„è¯è¯¥æ€ä¹ˆåŠï¼Ÿå¾ˆç®€å•ï¼Œç»™æ¯ç§ç±»å‹éƒ½å®šä¹‰ä¸ªæ–°ç±»å‹ï¼š

```go
type StringSlice []string
type Float32Slie []float32
type Float64Slice []float64
```

ä½†æ˜¯è¿™æ ·åšçš„é—®é¢˜æ˜¾è€Œæ˜“è§ï¼Œå®ƒä»¬ç»“æ„éƒ½æ˜¯ä¸€æ ·çš„åªæ˜¯æˆå‘˜ç±»å‹ä¸åŒå°±éœ€è¦é‡æ–°å®šä¹‰è¿™ä¹ˆå¤šæ–°ç±»å‹ã€‚é‚£ä¹ˆæœ‰æ²¡æœ‰ä¸€ä¸ªåŠæ³•èƒ½åªå®šä¹‰ä¸€ä¸ªç±»å‹å°±èƒ½ä»£è¡¨ä¸Šé¢è¿™æ‰€æœ‰çš„ç±»å‹å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„ï¼Œè¿™æ—¶å€™å°±éœ€è¦ç”¨åˆ°æ³›å‹äº†ï¼š

```go
type Slice[T int|float32|float64 ] []T
```

ä¸åŒäºä¸€èˆ¬çš„ç±»å‹å®šä¹‰ï¼Œè¿™é‡Œç±»å‹åç§° `Slice` åå¸¦äº†ä¸­æ‹¬å·ï¼Œå¯¹å„ä¸ªéƒ¨åˆ†åšä¸€ä¸ªè§£è¯´å°±æ˜¯ï¼š

- `T` å°±æ˜¯ä¸Šé¢ä»‹ç»è¿‡çš„**ç±»å‹å½¢å‚(Type parameter)**ï¼Œåœ¨å®šä¹‰ Slice ç±»å‹çš„æ—¶å€™ T ä»£è¡¨çš„å…·ä½“ç±»å‹å¹¶ä¸ç¡®å®šï¼Œç±»ä¼¼ä¸€ä¸ªå ä½ç¬¦
- `int|float32|float64` è¿™éƒ¨åˆ†è¢«ç§°ä¸º**ç±»å‹çº¦æŸ(Type constraint)**ï¼Œä¸­é—´çš„ `|` çš„æ„æ€æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œç±»å‹å½¢å‚ T åªå¯ä»¥æ¥æ”¶ int æˆ– float32 æˆ– float64 è¿™ä¸‰ç§ç±»å‹çš„å®å‚
- ä¸­æ‹¬å·é‡Œçš„ `T int|float32|float64` è¿™ä¸€æ•´ä¸²å› ä¸ºå®šä¹‰äº†æ‰€æœ‰çš„ç±»å‹å½¢å‚(åœ¨è¿™ä¸ªä¾‹å­é‡Œåªæœ‰ä¸€ä¸ªç±»å‹å½¢å‚ Tï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ç§°å…¶ä¸º **ç±»å‹å½¢å‚åˆ—è¡¨(type parameter list)**
- è¿™é‡Œæ–°å®šä¹‰çš„ç±»å‹åç§°å« `Slice[T]`

è¿™ç§ç±»å‹å®šä¹‰çš„æ–¹å¼ä¸­å¸¦äº†ç±»å‹å½¢å‚ï¼Œå¾ˆæ˜æ˜¾å’Œæ™®é€šçš„ç±»å‹å®šä¹‰éå¸¸ä¸ä¸€æ ·ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†è¿™ç§

> ç±»å‹å®šä¹‰ä¸­å¸¦ **ç±»å‹å½¢å‚** **çš„ç±»å‹ï¼Œç§°ä¹‹ä¸º **æ³›å‹ç±»å‹(Generic type)\*\*

æ³›å‹ç±»å‹ä¸èƒ½ç›´æ¥æ‹¿æ¥ä½¿ç”¨ï¼Œå¿…é¡»ä¼ å…¥**ç±»å‹å®å‚(Type argument)** å°†å…¶ç¡®å®šä¸ºå…·ä½“çš„ç±»å‹ä¹‹åæ‰å¯ä½¿ç”¨ã€‚è€Œä¼ å…¥ç±»å‹å®å‚ç¡®å®šå…·ä½“ç±»å‹çš„æ“ä½œè¢«ç§°ä¸º **å®ä¾‹åŒ–(Instantiations)** ï¼š

```go
// è¿™é‡Œä¼ å…¥äº†ç±»å‹å®å‚intï¼Œæ³›å‹ç±»å‹Slice[T]è¢«å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹ Slice[int]
var a Slice[int] = []int{1, 2, 3}
fmt.Printf("Type Name: %T",a)  //è¾“å‡ºï¼šType Name: Slice[int]

// ä¼ å…¥ç±»å‹å®å‚float32, å°†æ³›å‹ç±»å‹Slice[T]å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹ Slice[string]
var b Slice[float32] = []float32{1.0, 2.0, 3.0}
fmt.Printf("Type Name: %T",b)  //è¾“å‡ºï¼šType Name: Slice[float32]

// âœ— é”™è¯¯ã€‚å› ä¸ºå˜é‡açš„ç±»å‹ä¸ºSlice[int]ï¼Œbçš„ç±»å‹ä¸ºSlice[float32]ï¼Œä¸¤è€…ç±»å‹ä¸åŒ
a = b

// âœ— é”™è¯¯ã€‚stringä¸åœ¨ç±»å‹çº¦æŸ int|float32|float64 ä¸­ï¼Œä¸èƒ½ç”¨æ¥å®ä¾‹åŒ–æ³›å‹ç±»å‹
var c Slice[string] = []string{"Hello", "World"}

// âœ— é”™è¯¯ã€‚Slice[T]æ˜¯æ³›å‹ç±»å‹ï¼Œä¸å¯ç›´æ¥ä½¿ç”¨å¿…é¡»å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹
var x Slice[T] = []int{1, 2, 3}
```

å¯¹äºä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬å…ˆç»™æ³›å‹ç±»å‹ `Slice[T]` ä¼ å…¥äº†ç±»å‹å®å‚ `int` ï¼Œè¿™æ ·æ³›å‹ç±»å‹å°±è¢«å®ä¾‹åŒ–ä¸ºäº†å…·ä½“ç±»å‹ `Slice[int]` ï¼Œè¢«å®ä¾‹åŒ–ä¹‹åçš„ç±»å‹å®šä¹‰å¯è¿‘ä¼¼è§†ä¸ºå¦‚ä¸‹ï¼š

```go
type Slice[int] []int     // å®šä¹‰äº†ä¸€ä¸ªæ™®é€šçš„ç±»å‹ Slice[int] ï¼Œå®ƒçš„åº•å±‚ç±»å‹æ˜¯ []int
```

æˆ‘ä»¬ç”¨å®ä¾‹åŒ–åçš„ç±»å‹ `Slice[int]` å®šä¹‰äº†ä¸€ä¸ªæ–°çš„å˜é‡ `a` ï¼Œè¿™ä¸ªå˜é‡å¯ä»¥å­˜å‚¨ int ç±»å‹çš„åˆ‡ç‰‡ã€‚ä¹‹åæˆ‘ä»¬è¿˜ç”¨åŒæ ·çš„æ–¹æ³•å®ä¾‹åŒ–å‡ºäº†å¦ä¸€ä¸ªç±»å‹ `Slice[float32]` ï¼Œå¹¶åˆ›å»ºäº†å˜é‡ `b` ã€‚

å› ä¸ºå˜é‡ a å’Œ b å°±æ˜¯å…·ä½“çš„ä¸åŒç±»å‹äº†(ä¸€ä¸ª Slice[int] ï¼Œä¸€ä¸ª Slice[float32]ï¼‰ï¼Œæ‰€ä»¥ `a = b` è¿™æ ·ä¸åŒç±»å‹ä¹‹é—´çš„å˜é‡èµ‹å€¼æ˜¯ä¸å…è®¸çš„ã€‚

åŒæ—¶ï¼Œå› ä¸º Slice[T] çš„ç±»å‹çº¦æŸé™å®šäº†åªèƒ½ä½¿ç”¨ int æˆ– float32 æˆ– float64 æ¥å®ä¾‹åŒ–è‡ªå·±ï¼Œæ‰€ä»¥ `Slice[string]` è¿™æ ·ä½¿ç”¨ string ç±»å‹æ¥å®ä¾‹åŒ–æ˜¯é”™è¯¯çš„ã€‚

ä¸Šé¢åªæ˜¯ä¸ªæœ€ç®€å•çš„ä¾‹å­ï¼Œå®é™…ä¸Šç±»å‹å½¢å‚çš„æ•°é‡å¯ä»¥è¿œè¿œä¸æ­¢ä¸€ä¸ªï¼Œå¦‚ä¸‹ï¼š

```go
// MyMapç±»å‹å®šä¹‰äº†ä¸¤ä¸ªç±»å‹å½¢å‚ KEY å’Œ VALUEã€‚åˆ†åˆ«ä¸ºä¸¤ä¸ªå½¢å‚æŒ‡å®šäº†ä¸åŒçš„ç±»å‹çº¦æŸ
// è¿™ä¸ªæ³›å‹ç±»å‹çš„åå­—å«ï¼š MyMap[KEY, VALUE]
type MyMap[KEY int | string, VALUE float32 | float64] map[KEY]VALUE

// ç”¨ç±»å‹å®å‚ string å’Œ flaot64 æ›¿æ¢äº†ç±»å‹å½¢å‚ KEY ã€ VALUEï¼Œæ³›å‹ç±»å‹è¢«å®ä¾‹åŒ–ä¸ºå…·ä½“çš„ç±»å‹ï¼šMyMap[string, float64]
var a MyMap[string, float64] = map[string]float64{
    "jack_score": 9.6,
    "bob_score":  8.4,
}
```

ç”¨ä¸Šé¢çš„ä¾‹å­é‡æ–°å¤ä¹ ä¸‹å„ç§æ¦‚å¿µçš„è¯ï¼š

- KEY å’Œ VALUE æ˜¯**ç±»å‹å½¢å‚**
- `int|string` æ˜¯ KEY çš„**ç±»å‹çº¦æŸ**ï¼Œ `float32|float64` æ˜¯ VALUE çš„**ç±»å‹çº¦æŸ**
- `KEY int|string, VALUE float32|float64` æ•´ä¸ªä¸€ä¸²æ–‡æœ¬å› ä¸ºå®šä¹‰äº†æ‰€æœ‰å½¢å‚æ‰€ä»¥è¢«ç§°ä¸º**ç±»å‹å½¢å‚åˆ—è¡¨**
- Map[KEY, VALUE] æ˜¯**æ³›å‹ç±»å‹**ï¼Œç±»å‹çš„åå­—å°±å« Map[KEY, VALUE]
- `var a MyMap[string, float64] = xx` ä¸­çš„ string å’Œ float64 æ˜¯**ç±»å‹å®å‚**ï¼Œç”¨äºåˆ†åˆ«æ›¿æ¢ KEY å’Œ VALUEï¼Œ**å®ä¾‹åŒ–**å‡ºäº†å…·ä½“çš„ç±»å‹ `MyMap[string, float64]`

è¿˜æœ‰ç‚¹å¤´æ™•ï¼Ÿæ²¡äº‹ï¼Œçš„ç¡®ä¸€ä¸‹å­æœ‰å¤ªå¤šæ¦‚å¿µäº†ï¼Œè¿™é‡Œç”¨ä¸€å¼ å›¾å°±èƒ½ç®€å•è¯´æ¸…æ¥šï¼š

![123.png](../../../../images/e8d55b0037a84f94809c8fa26f638599.awebp) Go æ³›å‹æ¦‚å¿µä¸€è§ˆ

## 3.1 å…¶ä»–çš„æ³›å‹ç±»å‹

æ‰€æœ‰ç±»å‹å®šä¹‰éƒ½å¯ä½¿ç”¨ç±»å‹å½¢å‚ï¼Œæ‰€ä»¥ä¸‹é¢è¿™ç§ç»“æ„ä½“ä»¥åŠæ¥å£çš„å®šä¹‰ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å‹å½¢å‚ï¼š

```go
// ä¸€ä¸ªæ³›å‹ç±»å‹çš„ç»“æ„ä½“ã€‚å¯ç”¨ int æˆ– sring ç±»å‹å®ä¾‹åŒ–
type MyStruct[T int | string] struct {
    Name string
    Data T
}

// ä¸€ä¸ªæ³›å‹æ¥å£(å…³äºæ³›å‹æ¥å£åœ¨ååŠéƒ¨åˆ†ä¼šè¯¦ç»†è®²è§£ï¼‰
type IPrintData[T int | float32 | string] interface {
    Print(data T)
}

// ä¸€ä¸ªæ³›å‹é€šé“ï¼Œå¯ç”¨ç±»å‹å®å‚ int æˆ– string å®ä¾‹åŒ–
type MyChan[T int | string] chan T
```

## 3.2 ç±»å‹å½¢å‚çš„äº’ç›¸å¥—ç”¨

ç±»å‹å½¢å‚æ˜¯å¯ä»¥äº’ç›¸å¥—ç”¨çš„ï¼Œå¦‚ä¸‹

```go
type WowStruct[T int | float32, S []T] struct {
    Data     S
    MaxValue T
    MinValue T
}
```

è¿™ä¸ªä¾‹å­çœ‹èµ·æ¥æœ‰ç‚¹å¤æ‚ä¸”éš¾ä»¥ç†è§£ï¼Œä½†å®é™…ä¸Šåªè¦è®°ä½ä¸€ç‚¹ï¼šä»»ä½•æ³›å‹ç±»å‹éƒ½å¿…é¡»ä¼ å…¥ç±»å‹å®å‚å®ä¾‹åŒ–æ‰å¯ä»¥ä½¿ç”¨ã€‚æ‰€ä»¥æˆ‘ä»¬è¿™å°±å°è¯•ä¼ å…¥ç±»å‹å®å‚çœ‹çœ‹ï¼š

```go
var ws WowStruct[int, []int]
// æ³›å‹ç±»å‹ WowStuct[T, S] è¢«å®ä¾‹åŒ–åçš„ç±»å‹åç§°å°±å« WowStruct[int, []int]
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¸º T ä¼ å…¥äº†å®å‚ `int`ï¼Œç„¶åå› ä¸º S çš„å®šä¹‰æ˜¯ `[]T` ï¼Œæ‰€ä»¥ S çš„å®å‚è‡ªç„¶æ˜¯ `[]int` ã€‚ç»è¿‡å®ä¾‹åŒ–ä¹‹å WowStruct[T,S] çš„å®šä¹‰ç±»ä¼¼å¦‚ä¸‹ï¼š

```go
// ä¸€ä¸ªå­˜å‚¨intç±»å‹åˆ‡ç‰‡ï¼Œä»¥åŠåˆ‡ç‰‡ä¸­æœ€å¤§ã€æœ€å°å€¼çš„ç»“æ„ä½“
type WowStruct[int, []int] struct {
    Data     []int
    MaxValue int
    MinValue int
}
```

å› ä¸º S çš„å®šä¹‰æ˜¯ []T ï¼Œæ‰€ä»¥ T ä¸€å®šå†³å®šäº†çš„è¯ S çš„å®å‚å°±ä¸èƒ½éšä¾¿ä¹±ä¼ äº†ï¼Œä¸‹é¢è¿™æ ·çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼š

```go
// é”™è¯¯ã€‚Sçš„å®šä¹‰æ˜¯[]Tï¼Œè¿™é‡ŒTä¼ å…¥äº†å®å‚int, æ‰€ä»¥Sçš„å®å‚åº”å½“ä¸º []int è€Œä¸èƒ½æ˜¯ []float32
ws := WowStruct[int, []float32]{
        Data:     []float32{1.0, 2.0, 3.0},
        MaxValue: 3,
        MinValue: 1,
    }
```

## 3.3 å‡ ç§è¯­æ³•é”™è¯¯

1. å®šä¹‰æ³›å‹ç±»å‹çš„æ—¶å€™ï¼Œ**åŸºç¡€ç±»å‹ä¸èƒ½åªæœ‰ç±»å‹å½¢å‚**ï¼Œå¦‚ä¸‹ï¼š

   ```go
   // é”™è¯¯ï¼Œç±»å‹å½¢å‚ä¸èƒ½å•ç‹¬ä½¿ç”¨
   type CommonType[T int|string|float32] T
   ```

2. å½“ç±»å‹çº¦æŸçš„ä¸€äº›å†™æ³•ä¼šè¢«ç¼–è¯‘å™¨è¯¯è®¤ä¸ºæ˜¯è¡¨è¾¾å¼æ—¶ä¼šæŠ¥é”™ã€‚å¦‚ä¸‹ï¼š

   ```go
   //âœ— é”™è¯¯ã€‚T *intä¼šè¢«ç¼–è¯‘å™¨è¯¯è®¤ä¸ºæ˜¯è¡¨è¾¾å¼ Tä¹˜ä»¥intï¼Œè€Œä¸æ˜¯intæŒ‡é’ˆ
   type NewType[T *int] []T
   // ä¸Šé¢ä»£ç å†ç¼–è¯‘å™¨çœ¼ä¸­ï¼šå®ƒè®¤ä¸ºä½ è¦å®šä¹‰ä¸€ä¸ªå­˜æ”¾åˆ‡ç‰‡çš„æ•°ç»„ï¼Œæ•°ç»„é•¿åº¦ç”± T ä¹˜ä»¥ int è®¡ç®—å¾—åˆ°
   type NewType [T * int][]T

   //âœ— é”™è¯¯ã€‚å’Œä¸Šé¢ä¸€æ ·ï¼Œè¿™é‡Œä¸å…‰*è¢«ä¼šè®¤ä¸ºæ˜¯ä¹˜å·ï¼Œ| è¿˜ä¼šè¢«è®¤ä¸ºæ˜¯æŒ‰ä½æˆ–æ“ä½œ
   type NewType2[T *int|*float64] []T

   //âœ— é”™è¯¯
   type NewType2 [T (int)] []T
   ```

   ä¸ºäº†é¿å…è¿™ç§è¯¯è§£ï¼Œè§£å†³åŠæ³•å°±æ˜¯ç»™ç±»å‹çº¦æŸåŒ…ä¸Š `interface{}` æˆ–åŠ ä¸Šé€—å·æ¶ˆé™¤æ­§ä¹‰ï¼ˆå…³äºæ¥å£å…·ä½“çš„ç”¨æ³•ä¼šåœ¨ååŠç¯‡æåŠï¼‰

   ```go
   type NewType[T interface{*int}] []T
   type NewType2[T interface{*int|*float64}] []T

   // å¦‚æœç±»å‹çº¦æŸä¸­åªæœ‰ä¸€ä¸ªç±»å‹ï¼Œå¯ä»¥æ·»åŠ ä¸ªé€—å·æ¶ˆé™¤æ­§ä¹‰
   type NewType3[T *int,] []T

   //âœ— é”™è¯¯ã€‚å¦‚æœç±»å‹çº¦æŸä¸æ­¢ä¸€ä¸ªç±»å‹ï¼ŒåŠ é€—å·æ˜¯ä¸è¡Œçš„
   type NewType4[T *int|*float32,] []T
   ```

   å› ä¸ºä¸Šé¢é€—å·çš„ç”¨æ³•é™åˆ¶æ¯”è¾ƒå¤§ï¼Œè¿™é‡Œæ¨èç»Ÿä¸€ç”¨ interface{} è§£å†³é—®é¢˜

## 3.4 ç‰¹æ®Šçš„æ³›å‹ç±»å‹

è¿™é‡Œè®¨è®ºç§æ¯”è¾ƒç‰¹æ®Šçš„æ³›å‹ç±»å‹ï¼Œå¦‚ä¸‹ï¼š

```go
type Wow[T int | string] int

var a Wow[int] = 123     // ç¼–è¯‘æ­£ç¡®
var b Wow[string] = 123  // ç¼–è¯‘æ­£ç¡®
var c Wow[string] = "hello" // ç¼–è¯‘é”™è¯¯ï¼Œå› ä¸º"hello"ä¸èƒ½èµ‹å€¼ç»™åº•å±‚ç±»å‹int
```

è¿™é‡Œè™½ç„¶ä½¿ç”¨äº†ç±»å‹å½¢å‚ï¼Œä½†å› ä¸ºç±»å‹å®šä¹‰æ˜¯ `type Wow[T int|string] int` ï¼Œæ‰€ä»¥æ— è®ºä¼ å…¥ä»€ä¹ˆç±»å‹å®å‚ï¼Œå®ä¾‹åŒ–åçš„æ–°ç±»å‹çš„åº•å±‚ç±»å‹éƒ½æ˜¯ int ã€‚æ‰€ä»¥ int ç±»å‹çš„æ•°å­— 123 å¯ä»¥èµ‹å€¼ç»™å˜é‡ a å’Œ bï¼Œä½† string ç±»å‹çš„å­—ç¬¦ä¸² â€œhelloâ€ ä¸èƒ½èµ‹å€¼ç»™ c

è¿™ä¸ªä¾‹å­æ²¡æœ‰ä»€ä¹ˆå…·ä½“æ„ä¹‰ï¼Œä½†æ˜¯å¯ä»¥è®©æˆ‘ä»¬ç†è§£æ³›å‹ç±»å‹çš„å®ä¾‹åŒ–çš„æœºåˆ¶

## 3.5 æ³›å‹ç±»å‹çš„å¥—å¨ƒ

æ³›å‹å’Œæ™®é€šçš„ç±»å‹ä¸€æ ·ï¼Œå¯ä»¥äº’ç›¸åµŒå¥—å®šä¹‰å‡ºæ›´åŠ å¤æ‚çš„æ–°ç±»å‹ï¼Œå¦‚ä¸‹ï¼š

```go
// å…ˆå®šä¹‰ä¸ªæ³›å‹ç±»å‹ Slice[T]
type Slice[T int|string|float32|float64] []T

// âœ— é”™è¯¯ã€‚æ³›å‹ç±»å‹Slice[T]çš„ç±»å‹çº¦æŸä¸­ä¸åŒ…å«uint, uint8
type UintSlice[T uint|uint8] Slice[T]

// âœ“ æ­£ç¡®ã€‚åŸºäºæ³›å‹ç±»å‹Slice[T]å®šä¹‰äº†æ–°çš„æ³›å‹ç±»å‹ FloatSlice[T] ã€‚FloatSlice[T]åªæ¥å—float32å’Œfloat64ä¸¤ç§ç±»å‹
type FloatSlice[T float32|float64] Slice[T]

// âœ“ æ­£ç¡®ã€‚åŸºäºæ³›å‹ç±»å‹Slice[T]å®šä¹‰çš„æ–°æ³›å‹ç±»å‹ IntAndStringSlice[T]
type IntAndStringSlice[T int|string] Slice[T]
// âœ“ æ­£ç¡® åŸºäºIntAndStringSlice[T]å¥—å¨ƒå®šä¹‰å‡ºçš„æ–°æ³›å‹ç±»å‹
type IntSlice[T int] IntAndStringSlice[T]

// åœ¨mapä¸­å¥—ä¸€ä¸ªæ³›å‹ç±»å‹Slice[T]
type WowMap[T int|string] map[string]Slice[T]
// åœ¨mapä¸­å¥—Slice[T]çš„å¦ä¸€ç§å†™æ³•
type WowMap2[T Slice[int] | Slice[string]] map[string]T
```

## 3.6 ç±»å‹çº¦æŸçš„ä¸¤ç§é€‰æ‹©

è§‚å¯Ÿä¸‹é¢ä¸¤ç§ç±»å‹çº¦æŸçš„å†™æ³•

```go
type WowStruct[T int|string] struct {
    Name string
    Data []T
}

type WowStruct2[T []int|[]string] struct {
    Name string
    Data T
}
```

ä»…é™äºè¿™ä¸ªä¾‹å­ï¼Œè¿™ä¸¤ç§å†™æ³•å’Œå®ç°çš„åŠŸèƒ½å…¶å®æ˜¯å·®ä¸å¤šçš„ï¼Œå®ä¾‹åŒ–ä¹‹åç»“æ„ä½“ç›¸åŒã€‚ä½†æ˜¯åƒä¸‹é¢è¿™ç§æƒ…å†µçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä½¿ç”¨å‰ä¸€ç§å†™æ³•ä¼šæ›´å¥½ï¼š

```go
type WowStruct3[T int | string] struct {
    Data     []T
    MaxValue T
    MinValue T
}
```

## 3.7 åŒ¿åç»“æ„ä½“ä¸æ”¯æŒæ³›å‹

æˆ‘ä»¬æœ‰æ—¶å€™ä¼šç»å¸¸ç”¨åˆ°åŒ¿åçš„ç»“æ„ä½“ï¼Œå¹¶åœ¨å®šä¹‰å¥½åŒ¿åç»“æ„ä½“ä¹‹åç›´æ¥åˆå§‹åŒ–ï¼š

```go
testCase := struct {
        caseName string
        got      int
        want     int
    }{
        caseName: "test OK",
        got:      100,
        want:     100,
    }
```

é‚£ä¹ˆåŒ¿åç»“æ„ä½“èƒ½ä¸èƒ½ä½¿ç”¨æ³›å‹å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä¸èƒ½ï¼Œä¸‹é¢çš„ç”¨æ³•æ˜¯é”™è¯¯çš„ï¼š

```go
testCase := struct[T int|string] {
        caseName string
        got      T
        want     T
    }[int]{
        caseName: "test OK",
        got:      100,
        want:     100,
    }
```

æ‰€ä»¥åœ¨ä½¿ç”¨æ³›å‹çš„æ—¶å€™æˆ‘ä»¬åªèƒ½æ”¾å¼ƒä½¿ç”¨åŒ¿åç»“æ„ä½“ï¼Œå¯¹äºå¾ˆå¤šåœºæ™¯æ¥è¯´è¿™ä¼šé€ æˆéº»çƒ¦ï¼ˆæœ€ä¸»è¦éº»çƒ¦é›†ä¸­åœ¨å•å…ƒæµ‹è¯•çš„æ—¶å€™ï¼Œä¸ºæ³›å‹åšå•å…ƒæµ‹è¯•ä¼šéå¸¸éº»çƒ¦ï¼Œè¿™ç‚¹æˆ‘ä¹‹åçš„æ–‡ç« å°†ä¼šè¯¦ç»†é˜è¿°ï¼‰

# 4. æ³›å‹ receiver

çœ‹äº†ä¸Šçš„ä¾‹å­ï¼Œä½ ä¸€å®šä¼šè¯´ï¼Œä»‹ç»äº†è¿™ä¹ˆå¤šå¤æ‚çš„æ¦‚å¿µï¼Œä½†å¥½åƒæ³›å‹ç±»å‹æ ¹æœ¬æ²¡ä»€ä¹ˆç”¨å¤„å•Šï¼Ÿ

æ˜¯çš„ï¼Œå•çº¯çš„æ³›å‹ç±»å‹å®é™…ä¸Šå¯¹å¼€å‘æ¥è¯´ç”¨å¤„å¹¶ä¸å¤§ã€‚ä½†æ˜¯å¦‚æœå°†æ³›å‹ç±»å‹å’Œæ¥ä¸‹æ¥è¦ä»‹ç»çš„æ³›å‹ receiver ç›¸ç»“åˆçš„è¯ï¼Œæ³›å‹å°±æœ‰äº†éå¸¸å¤§çš„å®ç”¨æ€§äº†

æˆ‘ä»¬çŸ¥é“ï¼Œå®šä¹‰äº†æ–°çš„æ™®é€šç±»å‹ä¹‹åå¯ä»¥ç»™ç±»å‹æ·»åŠ æ–¹æ³•ã€‚é‚£ä¹ˆå¯ä»¥ç»™æ³›å‹ç±»å‹æ·»åŠ æ–¹æ³•å—ï¼Ÿç­”æ¡ˆè‡ªç„¶æ˜¯å¯ä»¥çš„ï¼Œå¦‚ä¸‹ï¼š

```go
type MySlice[T int | float32] []T

func (s MySlice[T]) Sum() T {
    var sum T
    for _, value := range s {
        sum += value
    }
    return sum
}
```

è¿™ä¸ªä¾‹å­ä¸ºæ³›å‹ç±»å‹ `MySlice[T]` æ·»åŠ äº†ä¸€ä¸ªè®¡ç®—æˆå‘˜æ€»å’Œçš„æ–¹æ³• `Sum()` ã€‚æ³¨æ„è§‚å¯Ÿè¿™ä¸ªæ–¹æ³•çš„å®šä¹‰ï¼š

- é¦–å…ˆçœ‹ receiver `(s MySlice[T])` ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥æŠŠç±»å‹åç§° `MySlice[T]` å†™å…¥äº† receiver ä¸­
- ç„¶åæ–¹æ³•çš„è¿”å›å‚æ•°æˆ‘ä»¬ä½¿ç”¨äº†ç±»å‹å½¢å‚ T \*\*\*\*(å®é™…ä¸Šå¦‚æœæœ‰éœ€è¦çš„è¯ï¼Œæ–¹æ³•çš„æ¥æ”¶å‚æ•°ä¹Ÿå¯ä»¥å®ç”¨ç±»å‹å½¢å‚)
- åœ¨æ–¹æ³•çš„å®šä¹‰ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å‹å½¢å‚ T ï¼ˆåœ¨è¿™ä¸ªä¾‹å­é‡Œï¼Œæˆ‘ä»¬é€šè¿‡ `var sum T` å®šä¹‰äº†ä¸€ä¸ªæ–°çš„å˜é‡ `sum` )

å¯¹äºè¿™ä¸ªæ³›å‹ç±»å‹ `MySlice[T]` æˆ‘ä»¬è¯¥å¦‚ä½•ä½¿ç”¨ï¼Ÿè¿˜è®°ä¸è®°å¾—ä¹‹å‰å¼ºè°ƒè¿‡å¾ˆå¤šæ¬¡çš„ï¼Œæ³›å‹ç±»å‹æ— è®ºå¦‚ä½•éƒ½éœ€è¦å…ˆç”¨ç±»å‹å®å‚å®ä¾‹åŒ–ï¼Œæ‰€ä»¥ç”¨æ³•å¦‚ä¸‹ï¼š

```go
var s MySlice[int] = []int{1, 2, 3, 4}
fmt.Println(s.Sum()) // è¾“å‡ºï¼š10

var s2 MySlice[float32] = []float32{1.0, 2.0, 3.0, 4.0}
fmt.Println(s2.Sum()) // è¾“å‡ºï¼š10.0
```

è¯¥å¦‚ä½•ç†è§£ä¸Šé¢çš„å®ä¾‹åŒ–ï¼Ÿé¦–å…ˆæˆ‘ä»¬ç”¨ç±»å‹å®å‚ int å®ä¾‹åŒ–äº†æ³›å‹ç±»å‹ `MySlice[T]`ï¼Œæ‰€ä»¥æ³›å‹ç±»å‹å®šä¹‰ä¸­çš„æ‰€æœ‰ T éƒ½è¢«æ›¿æ¢ä¸º intï¼Œæœ€ç»ˆæˆ‘ä»¬å¯ä»¥æŠŠä»£ç çœ‹ä½œä¸‹é¢è¿™æ ·ï¼š

```go
type MySlice[int] []int // å®ä¾‹åŒ–åçš„ç±»å‹åå« MyIntSlice[int]

// æ–¹æ³•ä¸­æ‰€æœ‰ç±»å‹å½¢å‚ T éƒ½è¢«æ›¿æ¢ä¸ºç±»å‹å®å‚ int
func (s MySlice[int]) Sum() int {
    var sum int
    for _, value := range s {
        sum += value
    }
    return sum
}
```

ç”¨ float32 å®ä¾‹åŒ–å’Œç”¨ int å®ä¾‹åŒ–åŒç†ï¼Œæ­¤å¤„ä¸å†èµ˜è¿°ã€‚

é€šè¿‡æ³›å‹ receiverï¼Œæ³›å‹çš„å®ç”¨æ€§ä¸€ä¸‹å­å¾—åˆ°äº†å·¨å¤§çš„æ‰©å±•ã€‚åœ¨æ²¡æœ‰æ³›å‹ä¹‹å‰å¦‚æœæƒ³å®ç°é€šç”¨çš„æ•°æ®ç»“æ„ï¼Œè¯¸å¦‚ï¼šå †ã€æ ˆã€é˜Ÿåˆ—ã€é“¾è¡¨ä¹‹ç±»çš„è¯ï¼Œæˆ‘ä»¬çš„é€‰æ‹©åªæœ‰ä¸¤ä¸ªï¼š

- ä¸ºæ¯ç§ç±»å‹å†™ä¸€ä¸ªå®ç°
- ä½¿ç”¨ æ¥å£+åå°„

è€Œæœ‰äº†æ³›å‹ä¹‹åï¼Œæˆ‘ä»¬å°±èƒ½éå¸¸ç®€å•åœ°åˆ›å»ºé€šç”¨æ•°æ®ç»“æ„äº†ã€‚æ¥ä¸‹æ¥ç”¨ä¸€ä¸ªæ›´åŠ å®ç”¨çš„ä¾‹å­ â€”â€” é˜Ÿåˆ— æ¥è®²è§£

## 4.1 åŸºäºæ³›å‹çš„é˜Ÿåˆ—

é˜Ÿåˆ—æ˜¯ä¸€ç§å…ˆå…¥å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼Œå®ƒå’Œç°å®ä¸­æ’é˜Ÿä¸€æ ·ï¼Œæ•°æ®åªèƒ½ä»é˜Ÿå°¾æ”¾å…¥ã€ä»é˜Ÿé¦–å–å‡ºï¼Œå…ˆæ”¾å…¥çš„æ•°æ®ä¼˜å…ˆè¢«å–å‡ºæ¥

```go
// è¿™é‡Œç±»å‹çº¦æŸä½¿ç”¨äº†ç©ºæ¥å£ï¼Œä»£è¡¨çš„æ„æ€æ˜¯æ‰€æœ‰ç±»å‹éƒ½å¯ä»¥ç”¨æ¥å®ä¾‹åŒ–æ³›å‹ç±»å‹ Queue[T] (å…³äºæ¥å£åœ¨ååŠéƒ¨åˆ†ä¼šè¯¦ç»†ä»‹ç»ï¼‰
type Queue[T interface{}] struct {
    elements []T
}

// å°†æ•°æ®æ”¾å…¥é˜Ÿåˆ—å°¾éƒ¨
func (q *Queue[T]) Put(value T) {
    q.elements = append(q.elements, value)
}

// ä»é˜Ÿåˆ—å¤´éƒ¨å–å‡ºå¹¶ä»å¤´éƒ¨åˆ é™¤å¯¹åº”æ•°æ®
func (q *Queue[T]) Pop() (T, bool) {
    var value T
    if len(q.elements) == 0 {
        return value, true
    }

    value = q.elements[0]
    q.elements = q.elements[1:]
    return value, len(q.elements) == 0
}

// é˜Ÿåˆ—å¤§å°
func (q Queue[T]) Size() int {
    return len(q.elements)
}
```

ğŸ’¡ ä¸ºäº†æ–¹ä¾¿è¯´æ˜ï¼Œä¸Šé¢æ˜¯é˜Ÿåˆ—éå¸¸ç®€å•çš„ä¸€ç§å®ç°æ–¹æ³•ï¼Œæ²¡æœ‰è€ƒè™‘çº¿ç¨‹å®‰å…¨ç­‰å¾ˆå¤šé—®é¢˜

`Queue[T]` å› ä¸ºæ˜¯æ³›å‹ç±»å‹ï¼Œæ‰€ä»¥è¦ä½¿ç”¨çš„è¯å¿…é¡»å®ä¾‹åŒ–ï¼Œå®ä¾‹åŒ–ä¸ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š

```go
var q1 Queue[int]  // å¯å­˜æ”¾intç±»å‹æ•°æ®çš„é˜Ÿåˆ—
q1.Put(1)
q1.Put(2)
q1.Put(3)
q1.Pop() // 1
q1.Pop() // 2
q1.Pop() // 3

var q2 Queue[string]  // å¯å­˜æ”¾stringç±»å‹æ•°æ®çš„é˜Ÿåˆ—
q2.Put("A")
q2.Put("B")
q2.Put("C")
q2.Pop() // "A"
q2.Pop() // "B"
q2.Pop() // "C"

var q3 Queue[struct{Name string}]
var q4 Queue[[]int] // å¯å­˜æ”¾[]intåˆ‡ç‰‡çš„é˜Ÿåˆ—
var q5 Queue[chan int] // å¯å­˜æ”¾inté€šé“çš„é˜Ÿåˆ—
var q6 Queue[io.Reader] // å¯å­˜æ”¾æ¥å£çš„é˜Ÿåˆ—
// ......
```

## 4.2 åŠ¨æ€åˆ¤æ–­å˜é‡çš„ç±»å‹

ä½¿ç”¨æ¥å£çš„æ—¶å€™ç»å¸¸ä¼šç”¨åˆ°ç±»å‹æ–­è¨€æˆ– type swith æ¥ç¡®å®šæ¥å£å…·ä½“çš„ç±»å‹ï¼Œç„¶åå¯¹ä¸åŒç±»å‹åšå‡ºä¸åŒçš„å¤„ç†ï¼Œå¦‚ï¼š

```go
var i interface{} = 123
i.(int) // ç±»å‹æ–­è¨€

// type switch
switch i.(type) {
    case int:
        // do something
    case string:
        // do something
    default:
        // do something
    }
}
```

é‚£ä¹ˆä½ ä¸€å®šä¼šæƒ³åˆ°ï¼Œå¯¹äº `valut T` è¿™æ ·é€šè¿‡ç±»å‹å½¢å‚å®šä¹‰çš„å˜é‡ï¼Œæˆ‘ä»¬èƒ½ä¸èƒ½åˆ¤æ–­å…·ä½“ç±»å‹ç„¶åå¯¹ä¸åŒç±»å‹åšå‡ºä¸åŒå¤„ç†å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä¸å…è®¸çš„ï¼Œå¦‚ä¸‹ï¼š

```go
func (q *Queue[T]) Put(value T) {
    value.(int) // é”™è¯¯ã€‚æ³›å‹ç±»å‹å®šä¹‰çš„å˜é‡ä¸èƒ½ä½¿ç”¨ç±»å‹æ–­è¨€

    // é”™è¯¯ã€‚ä¸å…è®¸ä½¿ç”¨type switch æ¥åˆ¤æ–­ value çš„å…·ä½“ç±»å‹
    switch value.(type) {
    case int:
        // do something
    case string:
        // do something
    default:
        // do something
    }

    // ...
}
```

è™½ç„¶ type switch å’Œç±»å‹æ–­è¨€ä¸èƒ½ç”¨ï¼Œä½†æˆ‘ä»¬å¯é€šè¿‡åå°„æœºåˆ¶è¾¾åˆ°ç›®çš„ï¼š

```go
func (receiver Queue[T]) Put(value T) {
    // Printf() å¯è¾“å‡ºå˜é‡valueçš„ç±»å‹(åº•å±‚å°±æ˜¯é€šè¿‡åå°„å®ç°çš„)
    fmt.Printf("%T", value)

    // é€šè¿‡åå°„å¯ä»¥åŠ¨æ€è·å¾—å˜é‡valueçš„ç±»å‹ä»è€Œåˆ†æƒ…å†µå¤„ç†
    v := reflect.ValueOf(value)
    switch v.Kind() {
    case reflect.Int:
        // do something
    case reflect.String:
        // do something
    }
    // ...
}
```

è¿™çœ‹èµ·æ¥è¾¾åˆ°äº†æˆ‘ä»¬çš„ç›®çš„ï¼Œå¯æ˜¯å½“ä½ å†™å‡ºä¸Šé¢è¿™æ ·çš„ä»£ç æ—¶å€™å°±å‡ºç°äº†ä¸€ä¸ªé—®é¢˜ï¼š

> ä½ ä¸ºäº†é¿å…ä½¿ç”¨åå°„è€Œé€‰æ‹©äº†æ³›å‹ï¼Œç»“æœåˆ°å¤´æ¥åˆä¸ºäº†ä¸€äº›åŠŸèƒ½åœ¨åœ¨æ³›å‹ä¸­ä½¿ç”¨åå°„

å½“å‡ºç°è¿™ç§æƒ…å†µçš„æ—¶å€™ä½ å¯èƒ½éœ€è¦é‡æ–°æ€è€ƒä¸€ä¸‹ï¼Œè‡ªå·±çš„éœ€æ±‚æ˜¯ä¸æ˜¯çœŸçš„éœ€è¦ç”¨æ³›å‹ï¼ˆæ¯•ç«Ÿæ³›å‹æœºåˆ¶æœ¬èº«å°±å¾ˆå¤æ‚äº†ï¼Œå†åŠ ä¸Šåå°„çš„å¤æ‚åº¦ï¼Œå¢åŠ çš„å¤æ‚åº¦å¹¶ä¸ä¸€å®šå€¼å¾—ï¼‰

å½“ç„¶ï¼Œè¿™ä¸€åˆ‡é€‰æ‹©æƒéƒ½åœ¨ä½ è‡ªå·±çš„æ‰‹é‡Œï¼Œæ ¹æ®å…·ä½“æƒ…å†µæ–Ÿé…Œ

# 5. æ³›å‹å‡½æ•°

åœ¨ä»‹ç»å®Œæ³›å‹ç±»å‹å’Œæ³›å‹ receiver ä¹‹åï¼Œæˆ‘ä»¬æ¥ä»‹ç»æœ€åä¸€ä¸ªå¯ä»¥ä½¿ç”¨æ³›å‹çš„åœ°æ–¹â€”â€”æ³›å‹å‡½æ•°ã€‚æœ‰äº†ä¸Šé¢çš„çŸ¥è¯†ï¼Œå†™æ³›å‹å‡½æ•°ä¹Ÿååˆ†ç®€å•ã€‚å‡è®¾æˆ‘ä»¬æƒ³è¦å†™ä¸€ä¸ªè®¡ç®—ä¸¤ä¸ªæ•°ä¹‹å’Œçš„å‡½æ•°ï¼š

```go
func Add(a int, b int) int {
    return a + b
}
```

è¿™ä¸ªå‡½æ•°ç†æ‰€å½“ç„¶åªèƒ½è®¡ç®— int çš„å’Œï¼Œè€Œæµ®ç‚¹çš„è®¡ç®—æ˜¯ä¸æ”¯æŒçš„ã€‚è¿™æ—¶å€™æˆ‘ä»¬å¯ä»¥åƒä¸‹é¢è¿™æ ·å®šä¹‰ä¸€ä¸ªæ³›å‹å‡½æ•°ï¼š

```go
func Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
```

ä¸Šé¢å°±æ˜¯æ³›å‹å‡½æ•°çš„å®šä¹‰ã€‚

> è¿™ç§å¸¦ç±»å‹å½¢å‚çš„å‡½æ•°è¢«ç§°ä¸º**æ³›å‹å‡½æ•°**

å®ƒå’Œæ™®é€šå‡½æ•°çš„ç‚¹ä¸åŒåœ¨äºå‡½æ•°åä¹‹åå¸¦äº†ç±»å‹å½¢å‚ã€‚è¿™é‡Œçš„ç±»å‹å½¢å‚çš„æ„ä¹‰ã€å†™æ³•å’Œç”¨æ³•å› ä¸ºä¸æ³›å‹ç±»å‹æ˜¯ä¸€æ¨¡ä¸€æ ·çš„ï¼Œå°±ä¸å†èµ˜è¿°äº†ã€‚

å’Œæ³›å‹ç±»å‹ä¸€æ ·ï¼Œæ³›å‹å‡½æ•°ä¹Ÿæ˜¯ä¸èƒ½ç›´æ¥è°ƒç”¨çš„ï¼Œè¦ä½¿ç”¨æ³›å‹å‡½æ•°çš„è¯å¿…é¡»ä¼ å…¥ç±»å‹å®å‚ä¹‹åæ‰èƒ½è°ƒç”¨ã€‚

```go
Add[int](1,2) // ä¼ å…¥ç±»å‹å®å‚intï¼Œè®¡ç®—ç»“æœä¸º 3
Add[float32](1.0, 2.0) // ä¼ å…¥ç±»å‹å®å‚float32, è®¡ç®—ç»“æœä¸º 3.0

Add[string]("hello", "world") // é”™è¯¯ã€‚å› ä¸ºæ³›å‹å‡½æ•°Addçš„ç±»å‹çº¦æŸä¸­å¹¶ä¸åŒ…å«string
```

æˆ–è®¸ä½ ä¼šè§‰å¾—è¿™æ ·æ¯æ¬¡éƒ½è¦æ‰‹åŠ¨æŒ‡å®šç±»å‹å®å‚å¤ªä¸æ–¹ä¾¿äº†ã€‚æ‰€ä»¥ Go è¿˜æ”¯æŒç±»å‹å®å‚çš„è‡ªåŠ¨æ¨å¯¼ï¼š

```go
Add(1, 2)  // 1ï¼Œ2æ˜¯intç±»å‹ï¼Œç¼–è¯‘è¯·è‡ªåŠ¨æ¨å¯¼å‡ºç±»å‹å®å‚Tæ˜¯int
Add(1.0, 2.0) // 1.0, 2.0 æ˜¯æµ®ç‚¹ï¼Œç¼–è¯‘è¯·è‡ªåŠ¨æ¨å¯¼å‡ºç±»å‹å®å‚Tæ˜¯float32
```

è‡ªåŠ¨æ¨å¯¼çš„å†™æ³•å°±å¥½åƒå…å»äº†ä¼ å…¥å®å‚çš„æ­¥éª¤ä¸€æ ·ï¼Œä½†è¯·è®°ä½è¿™ä»…ä»…åªæ˜¯ç¼–è¯‘å™¨å¸®æˆ‘ä»¬æ¨å¯¼å‡ºäº†ç±»å‹å®å‚ï¼Œå®é™…ä¸Šä¼ å…¥å®å‚æ­¥éª¤è¿˜æ˜¯å‘ç”Ÿäº†çš„ã€‚

## 5.1 åŒ¿åå‡½æ•°ä¸æ”¯æŒæ³›å‹

åœ¨ Go ä¸­æˆ‘ä»¬ç»å¸¸ä¼šä½¿ç”¨åŒ¿åå‡½æ•°ï¼Œå¦‚ï¼š

```go
fn := func(a, b int) int {
    return a + b
}  // å®šä¹‰äº†ä¸€ä¸ªåŒ¿åå‡½æ•°å¹¶èµ‹å€¼ç»™ fn

fmt.Println(fn(1, 2)) // è¾“å‡º: 3
```

é‚£ä¹ˆ Go æ”¯ä¸æ”¯æŒåŒ¿åæ³›å‹å‡½æ•°å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä¸èƒ½â€”â€”**åŒ¿åå‡½æ•°ä¸èƒ½è‡ªå·±å®šä¹‰ç±»å‹å½¢å‚ï¼š**

```go
// é”™è¯¯ï¼ŒåŒ¿åå‡½æ•°ä¸èƒ½è‡ªå·±å®šä¹‰ç±»å‹å®å‚
fnGeneric := func[T int | float32](a, b T) T {
        return a + b
}

fmt.Println(fnGeneric(1, 2))
```

ä½†æ˜¯åŒ¿åå‡½æ•°å¯ä»¥ä½¿ç”¨åˆ«å¤„å®šä¹‰å¥½çš„ç±»å‹å®å‚ï¼Œå¦‚ï¼š

```go
func MyFunc[T int | float32 | float64](a, b T) {

    // åŒ¿åå‡½æ•°å¯ä½¿ç”¨å·²ç»å®šä¹‰å¥½çš„ç±»å‹å½¢å‚
    fn2 := func(i T, j T) T {
        return i*2 - j*2
    }

    fn2(a, b)
}
```

## 5.2 æ—¢ç„¶æ”¯æŒæ³›å‹å‡½æ•°ï¼Œé‚£ä¹ˆæ³›å‹æ–¹æ³•å‘¢ï¼Ÿ

æ—¢ç„¶å‡½æ•°éƒ½æ”¯æŒæ³›å‹äº†ï¼Œé‚£ä½ åº”è¯¥è‡ªç„¶ä¼šæƒ³åˆ°ï¼Œæ–¹æ³•æ”¯ä¸æ”¯æŒæ³›å‹ï¼Ÿå¾ˆä¸å¹¸ï¼Œç›®å‰ Go çš„æ–¹æ³•å¹¶ä¸æ”¯æŒæ³›å‹ï¼Œå¦‚ä¸‹ï¼š

```go
type A struct {
}

// ä¸æ”¯æŒæ³›å‹æ–¹æ³•
func (receiver A) Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
```

ä½†æ˜¯å› ä¸º receiver æ”¯æŒæ³›å‹ï¼Œ æ‰€ä»¥å¦‚æœæƒ³åœ¨æ–¹æ³•ä¸­ä½¿ç”¨æ³›å‹çš„è¯ï¼Œç›®å‰å”¯ä¸€çš„åŠæ³•å°±æ˜¯æ›²çº¿æ•‘å›½ï¼Œè¿‚å›åœ°é€šè¿‡ receiver ä½¿ç”¨ç±»å‹å½¢å‚ï¼š

```go
type A[T int | float32 | float64] struct {
}

// æ–¹æ³•å¯ä»¥ä½¿ç”¨ç±»å‹å®šä¹‰ä¸­çš„å½¢å‚ T
func (receiver A[T]) Add(a T, b T) T {
    return a + b
}

// ç”¨æ³•ï¼š
var a A[int]
a.Add(1, 2)

var aa A[float32]
aa.Add(1.0, 2.0)
```

# å‰åŠå°ç»“

è®²å®Œäº†æ³›å‹ç±»å‹ã€æ³›å‹ receiverã€æ³›å‹å‡½æ•°åï¼ŒGo çš„æ³›å‹ç®—æ˜¯ä»‹ç»å®Œä¸€åŠå¤šäº†ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬åšä¸€ä¸ªæ¦‚å¿µçš„å°ç»“ï¼š

1. Go çš„æ³›å‹(æˆ–è€…æˆ–ç±»å‹å½¢å‚)ç›®å‰å¯ä½¿ç”¨åœ¨ 3 ä¸ªåœ°æ–¹
   1. æ³›å‹ç±»å‹ - ç±»å‹å®šä¹‰ä¸­å¸¦ç±»å‹å½¢å‚çš„ç±»å‹
   2. æ³›å‹ receiver - æ³›å‹ç±»å‹çš„ receiver
   3. æ³›å‹å‡½æ•° - å¸¦ç±»å‹å½¢å‚çš„å‡½æ•°
2. ä¸ºäº†å®ç°æ³›å‹ï¼ŒGo å¼•å…¥äº†ä¸€äº›æ–°çš„æ¦‚å¿µï¼š
   1. ç±»å‹å½¢å‚
   2. ç±»å‹å½¢å‚åˆ—è¡¨
   3. ç±»å‹å®å‚
   4. ç±»å‹çº¦æŸ
   5. å®ä¾‹åŒ– - æ³›å‹ç±»å‹ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œè¦ä½¿ç”¨çš„è¯å¿…é¡»ä¼ å…¥ç±»å‹å®å‚è¿›è¡Œå®ä¾‹åŒ–

ä»€ä¹ˆï¼Œè¿™æ–‡ç« å·²ç»å¾ˆé•¿å¾ˆå¤æ‚äº†ï¼Œæ‰è®²äº†ä¸€åŠï¼Ÿæ˜¯çš„ï¼ŒGo è¿™æ¬¡ 1.18 å¼•å…¥æ³›å‹ä¸ºè¯­è¨€å¢åŠ äº†è¾ƒå¤§çš„å¤æ‚åº¦ï¼Œç›®å‰è¿˜åªæ˜¯æ–°æ¦‚å¿µçš„ä»‹ç»ï¼Œä¸‹é¢ååŠæ®µå°†ä»‹ç» Go å¼•å…¥æ³›å‹åå¯¹æ¥å£åšå‡ºçš„é‡å¤§è°ƒæ•´ã€‚é‚£ä¹ˆåšå¥½å¿ƒç†å‡†å¤‡ï¼Œæˆ‘ä»¬å‡ºå‘å§ã€‚

# 6. å˜å¾—å¤æ‚çš„æ¥å£

æœ‰æ—¶å€™ä½¿ç”¨æ³›å‹ç¼–ç¨‹æ—¶ï¼Œæˆ‘ä»¬ä¼šä¹¦å†™é•¿é•¿çš„ç±»å‹çº¦æŸï¼Œå¦‚ä¸‹ï¼š

```go
// ä¸€ä¸ªå¯ä»¥å®¹çº³æ‰€æœ‰int,uintä»¥åŠæµ®ç‚¹ç±»å‹çš„æ³›å‹åˆ‡ç‰‡
type Slice[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64] []T
```

ç†æ‰€å½“ç„¶ï¼Œè¿™ç§å†™æ³•æ˜¯æˆ‘ä»¬æ— æ³•å¿å—ä¹Ÿéš¾ä»¥ç»´æŠ¤çš„ï¼Œè€Œ Go æ”¯æŒå°†ç±»å‹çº¦æŸå•ç‹¬æ‹¿å‡ºæ¥å®šä¹‰åˆ°æ¥å£ä¸­ï¼Œä»è€Œè®©ä»£ç æ›´å®¹æ˜“ç»´æŠ¤ï¼š

```go
type IntUintFloat interface {
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
}

type Slice[T IntUintFloat] []T
```

è¿™æ®µä»£ç æŠŠç±»å‹çº¦æŸç»™å•ç‹¬æ‹¿å‡ºæ¥ï¼Œå†™å…¥äº†æ¥å£ç±»å‹ `IntUintFloat` å½“ä¸­ã€‚éœ€è¦æŒ‡å®šç±»å‹çº¦æŸçš„æ—¶å€™ç›´æ¥ä½¿ç”¨æ¥å£ `IntUintFloat` å³å¯ã€‚

ä¸è¿‡è¿™æ ·çš„ä»£ç ä¾æ—§ä¸å¥½ç»´æŠ¤ï¼Œè€Œæ¥å£å’Œæ¥å£ã€æ¥å£å’Œæ™®é€šç±»å‹ä¹‹é—´ä¹Ÿæ˜¯å¯ä»¥é€šè¿‡ `|` è¿›è¡Œç»„åˆï¼š

```go
type Int interface {
    int | int8 | int16 | int32 | int64
}

type Uint interface {
    uint | uint8 | uint16 | uint32
}

type Float interface {
    float32 | float64
}

type Slice[T Int | Uint | Float] []T  // ä½¿ç”¨ '|' å°†å¤šä¸ªæ¥å£ç±»å‹ç»„åˆ
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«å®šä¹‰äº† Int, Uint, Float ä¸‰ä¸ªæ¥å£ç±»å‹ï¼Œå¹¶æœ€ç»ˆåœ¨ Slice[T] çš„ç±»å‹çº¦æŸä¸­é€šè¿‡ä½¿ç”¨ `|` å°†å®ƒä»¬ç»„åˆåˆ°ä¸€èµ·ã€‚

åŒæ—¶ï¼Œåœ¨æ¥å£é‡Œä¹Ÿèƒ½ç›´æ¥ç»„åˆå…¶ä»–æ¥å£ï¼Œæ‰€ä»¥è¿˜å¯ä»¥åƒä¸‹é¢è¿™æ ·ï¼š

```go
type SliceElement interface {
    Int | Uint | Float | string // ç»„åˆäº†ä¸‰ä¸ªæ¥å£ç±»å‹å¹¶é¢å¤–å¢åŠ äº†ä¸€ä¸ª string ç±»å‹
}

type Slice[T SliceElement] []T
```

## 6.1 `~` : æŒ‡å®šåº•å±‚ç±»å‹

ä¸Šé¢å®šä¹‰çš„ Slie[T] è™½ç„¶å¯ä»¥è¾¾åˆ°ç›®çš„ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼š

```go
var s1 Slice[int] // æ­£ç¡®

type MyInt int
var s2 Slice[MyInt] // âœ— é”™è¯¯ã€‚MyIntç±»å‹åº•å±‚ç±»å‹æ˜¯intä½†å¹¶ä¸æ˜¯intç±»å‹ï¼Œä¸ç¬¦åˆ Slice[T] çš„ç±»å‹çº¦æŸ
```

è¿™é‡Œå‘ç”Ÿé”™è¯¯çš„åŸå› æ˜¯ï¼Œæ³›å‹ç±»å‹ Slice[T] å…è®¸çš„æ˜¯ int ä½œä¸ºç±»å‹å®å‚ï¼Œè€Œä¸æ˜¯ MyInt ï¼ˆè™½ç„¶ MyInt ç±»å‹åº•å±‚ç±»å‹æ˜¯ int ï¼Œä½†å®ƒä¾æ—§ä¸æ˜¯ int ç±»å‹ï¼‰ã€‚

ä¸ºäº†ä»æ ¹æœ¬ä¸Šè§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒGo æ–°å¢äº†ä¸€ä¸ªç¬¦å· `~` ï¼Œåœ¨ç±»å‹çº¦æŸä¸­ä½¿ç”¨ç±»ä¼¼ `~int` è¿™ç§å†™æ³•çš„è¯ï¼Œå°±ä»£è¡¨ç€ä¸å…‰æ˜¯ int ï¼Œæ‰€æœ‰ä»¥ int ä¸ºåº•å±‚ç±»å‹çš„ç±»å‹ä¹Ÿéƒ½å¯ç”¨äºå®ä¾‹åŒ–ã€‚

ä½¿ç”¨ ~ å¯¹ä»£ç è¿›è¡Œæ”¹å†™ä¹‹åå¦‚ä¸‹ï¼š

```go
type Int interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32
}
type Float interface {
    ~float32 | ~float64
}

type Slice[T Int | Uint | Float] []T

var s Slice[int] // æ­£ç¡®

type MyInt int
var s2 Slice[MyInt]  // MyIntåº•å±‚ç±»å‹æ˜¯intï¼Œæ‰€ä»¥å¯ä»¥ç”¨äºå®ä¾‹åŒ–

type MyMyInt MyInt
var s3 Slice[MyMyInt]  // æ­£ç¡®ã€‚MyMyInt è™½ç„¶åŸºäº MyInt ï¼Œä½†åº•å±‚ç±»å‹ä¹Ÿæ˜¯intï¼Œæ‰€ä»¥ä¹Ÿèƒ½ç”¨äºå®ä¾‹åŒ–

type MyFloat32 float32  // æ­£ç¡®
var s4 Slice[MyFloat32]
```

**é™åˆ¶**ï¼šä½¿ç”¨ `~` æ—¶æœ‰ä¸€å®šçš„é™åˆ¶ï¼š

1. ~åé¢çš„ç±»å‹ä¸èƒ½ä¸ºæ¥å£
2. ~åé¢çš„ç±»å‹å¿…é¡»ä¸ºåŸºæœ¬ç±»å‹

```go
type MyInt int

type _ interface {
    ~[]byte  // æ­£ç¡®
    ~MyInt   // é”™è¯¯ï¼Œ~åçš„ç±»å‹å¿…é¡»ä¸ºåŸºæœ¬ç±»å‹
    ~error   // é”™è¯¯ï¼Œ~åçš„ç±»å‹ä¸èƒ½ä¸ºæ¥å£
}
```

## 6.2 ä»æ–¹æ³•é›†(Method set)åˆ°ç±»å‹é›†(Type set)

ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ åˆ°äº†ä¸€ç§æ¥å£çš„å…¨æ–°å†™æ³•ï¼Œè€Œè¿™ç§å†™æ³•åœ¨ Go1.18 ä¹‹å‰æ˜¯ä¸å­˜åœ¨çš„ã€‚å¦‚æœä½ æ¯”è¾ƒæ•é”çš„è¯ï¼Œä¸€å®šä¼šéšçº¦è®¤è¯†åˆ°è¿™ç§å†™æ³•çš„æ”¹å˜è¿™ä¹Ÿä¸€å®šæ„å‘³ç€ Go è¯­è¨€ä¸­ `æ¥å£(interface)` è¿™ä¸ªæ¦‚å¿µå‘ç”Ÿäº†éå¸¸å¤§çš„å˜åŒ–ã€‚

æ˜¯çš„ï¼Œåœ¨ Go1.18 ä¹‹å‰ï¼ŒGo å®˜æ–¹å¯¹ `æ¥å£(interface)` çš„å®šä¹‰æ˜¯ï¼šæ¥å£æ˜¯ä¸€ä¸ªæ–¹æ³•é›†(method set)

> An interface type specifies a **method set** called its interface

å°±å¦‚ä¸‹é¢è¿™ä¸ªä»£ç ä¸€æ ·ï¼Œ `ReadWriter` æ¥å£å®šä¹‰äº†ä¸€ä¸ªæ¥å£(æ–¹æ³•é›†)ï¼Œè¿™ä¸ªé›†åˆä¸­åŒ…å«äº† `Read()` å’Œ `Write()` è¿™ä¸¤ä¸ªæ–¹æ³•ã€‚æ‰€æœ‰åŒæ—¶å®šä¹‰äº†è¿™ä¸¤ç§æ–¹æ³•çš„ç±»å‹è¢«è§†ä¸ºå®ç°äº†è¿™ä¸€æ¥å£ã€‚

```go
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

ä½†æ˜¯ï¼Œæˆ‘ä»¬å¦‚æœæ¢ä¸€ä¸ªè§’åº¦æ¥é‡æ–°æ€è€ƒä¸Šé¢è¿™ä¸ªæ¥å£çš„è¯ï¼Œä¼šå‘ç°æ¥å£çš„å®šä¹‰å®é™…ä¸Šè¿˜èƒ½è¿™æ ·ç†è§£ï¼š

> æˆ‘ä»¬å¯ä»¥æŠŠ `ReaderWriter` æ¥å£çœ‹æˆä»£è¡¨äº†ä¸€ä¸ª **ç±»å‹çš„é›†åˆ**ï¼Œæ‰€æœ‰å®ç°äº† `Read()` `Writer()` è¿™ä¸¤ä¸ªæ–¹æ³•çš„ç±»å‹éƒ½åœ¨æ¥å£ä»£è¡¨çš„ç±»å‹é›†åˆå½“ä¸­

é€šè¿‡æ¢ä¸ªè§’åº¦çœ‹å¾…æ¥å£ï¼Œåœ¨æˆ‘ä»¬çœ¼ä¸­æ¥å£çš„å®šä¹‰å°±ä» **`æ–¹æ³•é›†(method set)`** å˜ä¸ºäº† **`ç±»å‹é›†(type set)`**ã€‚è€Œ Go1.18 å¼€å§‹å°±æ˜¯ä¾æ®è¿™ä¸€ç‚¹å°†æ¥å£çš„å®šä¹‰æ­£å¼æ›´æ”¹ä¸ºäº† **ç±»å‹é›†(Type set)**

> An interface type defines a **\*type set** (ä¸€ä¸ª\*æ¥å£ç±»å‹å®šä¹‰äº†ä¸€ä¸ªç±»å‹é›†)

ä½ æˆ–è®¸ä¼šè§‰å¾—ï¼Œè¿™ä¸å°±æ˜¯æ”¹äº†ä¸‹æ¦‚å¿µä¸Šçš„å®šä¹‰å®é™…ä¸Šæ²¡ä»€ä¹ˆç”¨å—ï¼Ÿæ˜¯çš„ï¼Œå¦‚æœæ¥å£åŠŸèƒ½æ²¡å˜åŒ–çš„è¯ç¡®å®å¦‚æ­¤ã€‚ä½†æ˜¯è¿˜è®°å¾—ä¸‹é¢è¿™ç§ç”¨æ¥å£æ¥ç®€åŒ–ç±»å‹çº¦æŸçš„å†™æ³•å—ï¼š

```go
type Float interface {
    ~float32 | ~float64
}

type Slice[T Float] []T
```

è¿™å°±ä½“ç°å‡ºäº†ä¸ºä»€ä¹ˆè¦æ›´æ”¹æ¥å£çš„å®šä¹‰äº†ã€‚ç”¨ **ç±»å‹é›†** çš„æ¦‚å¿µé‡æ–°ç†è§£ä¸Šé¢çš„ä»£ç çš„è¯å°±æ˜¯ï¼š

> æ¥å£ç±»å‹ Float ä»£è¡¨äº†ä¸€ä¸ª **ç±»å‹é›†åˆ**ï¼Œ æ‰€æœ‰ä»¥ float32 **æˆ–** float64 ä¸ºåº•å±‚ç±»å‹çš„ç±»å‹ï¼Œéƒ½åœ¨è¿™ä¸€ç±»å‹é›†ä¹‹ä¸­

è€Œ `type Slice[T Float] []T` ä¸­ï¼Œ **ç±»å‹çº¦æŸ** çš„çœŸæ­£æ„æ€æ˜¯ï¼š

> **ç±»å‹çº¦æŸ** æŒ‡å®šäº†ç±»å‹å½¢å‚å¯æ¥å—çš„ç±»å‹é›†åˆï¼Œåªæœ‰å±äºè¿™ä¸ªé›†åˆä¸­çš„ç±»å‹æ‰èƒ½æ›¿æ¢å½¢å‚ç”¨äºå®ä¾‹åŒ–

å¦‚ï¼š

```go
var s Slice[int]      // int å±äºç±»å‹é›† Float ï¼Œæ‰€ä»¥intå¯ä»¥ä½œä¸ºç±»å‹å®å‚
var s Slice[chan int] // chan int ç±»å‹ä¸åœ¨ç±»å‹é›† Float ä¸­ï¼Œæ‰€ä»¥é”™è¯¯
```

### 6.2.1 æ¥å£å®ç°(implement)å®šä¹‰çš„å˜åŒ–

æ—¢ç„¶æ¥å£å®šä¹‰å‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£ä¹ˆä» Go1.18 å¼€å§‹ `æ¥å£å®ç°(implement)` çš„å®šä¹‰è‡ªç„¶ä¹Ÿå‘ç”Ÿäº†å˜åŒ–ï¼š

å½“æ»¡è¶³ä»¥ä¸‹æ¡ä»¶æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è¯´ **ç±»å‹ T å®ç°äº†æ¥å£ I ( type T implements interface I)**ï¼š

- T ä¸æ˜¯æ¥å£æ—¶ï¼šç±»å‹ T æ˜¯æ¥å£ I ä»£è¡¨çš„ç±»å‹é›†ä¸­çš„ä¸€ä¸ªæˆå‘˜ (T is an element of the type set of I)
- T æ˜¯æ¥å£æ—¶ï¼š T æ¥å£ä»£è¡¨çš„ç±»å‹é›†æ˜¯ I ä»£è¡¨çš„ç±»å‹é›†çš„å­é›†(Type set of T is a subset of the type set of I)

### 6.2.2 **ç±»å‹çš„å¹¶é›†**

å¹¶é›†æˆ‘ä»¬å·²ç»å¾ˆç†Ÿæ‚‰äº†ï¼Œä¹‹å‰ä¸€ç›´ä½¿ç”¨çš„ `|` ç¬¦å·å°±æ˜¯æ±‚ç±»å‹çš„å¹¶é›†( `union` )

```go
type Uint interface {  // ç±»å‹é›† Uint æ˜¯ ~uint å’Œ ~uint8 ç­‰ç±»å‹çš„å¹¶é›†
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}
```

### 6.2.3 ç±»å‹çš„äº¤é›†

æ¥å£å¯ä»¥ä¸æ­¢ä¹¦å†™ä¸€è¡Œï¼Œå¦‚æœä¸€ä¸ªæ¥å£æœ‰å¤šè¡Œç±»å‹å®šä¹‰ï¼Œé‚£ä¹ˆå–å®ƒä»¬ä¹‹é—´çš„ **äº¤é›†**

```go
type AllInt interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint32
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type A interface { // æ¥å£Aä»£è¡¨çš„ç±»å‹é›†æ˜¯ AllInt å’Œ Uint çš„äº¤é›†
    AllInt
    Uint
}

type B interface { // æ¥å£Bä»£è¡¨çš„ç±»å‹é›†æ˜¯ AllInt å’Œ ~int çš„äº¤é›†
    AllInt
    ~int
}
```

ä¸Šé¢è¿™ä¸ªä¾‹å­ä¸­

- æ¥å£ A ä»£è¡¨çš„æ˜¯ AllInt ä¸ Uint çš„ **äº¤é›†**ï¼Œå³ `~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64`
- æ¥å£ B ä»£è¡¨çš„åˆ™æ˜¯ AllInt å’Œ ~int çš„**äº¤é›†**ï¼Œå³ `~int`

é™¤äº†ä¸Šé¢çš„äº¤é›†ï¼Œä¸‹é¢ä¹Ÿæ˜¯ä¸€ç§äº¤é›†ï¼š

```go
type C interface {
    ~int
    int
}
```

å¾ˆæ˜¾ç„¶ï¼Œ~int å’Œ int çš„äº¤é›†åªæœ‰ int ä¸€ç§ç±»å‹ï¼Œæ‰€ä»¥æ¥å£ C ä»£è¡¨çš„ç±»å‹é›†ä¸­åªæœ‰ int ä¸€ç§ç±»å‹

### 6.2.4 ç©ºé›†

å½“å¤šä¸ªç±»å‹çš„äº¤é›†å¦‚ä¸‹é¢ `Bad` è¿™æ ·ä¸ºç©ºçš„æ—¶å€™ï¼Œ `Bad` è¿™ä¸ªæ¥å£ä»£è¡¨çš„ç±»å‹é›†ä¸ºä¸€ä¸ª**ç©ºé›†**ï¼š

```go
type Bad interface {
    int
    float32
} // ç±»å‹ int å’Œ float32 æ²¡æœ‰ç›¸äº¤çš„ç±»å‹ï¼Œæ‰€ä»¥æ¥å£ Bad ä»£è¡¨çš„ç±»å‹é›†ä¸ºç©º
```

**æ²¡æœ‰ä»»ä½•ä¸€ç§ç±»å‹å±äºç©ºé›†**ã€‚è™½ç„¶ Bad è¿™æ ·çš„å†™æ³•æ˜¯å¯ä»¥ç¼–è¯‘çš„ï¼Œä½†å®é™…ä¸Šå¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰

### 6.2.5 ç©ºæ¥å£å’Œ any

ä¸Šé¢è¯´äº†ç©ºé›†ï¼Œæ¥ä¸‹æ¥è¯´ä¸€ä¸ªç‰¹æ®Šçš„ç±»å‹é›†â€”â€”`ç©ºæ¥å£ interface{}` ã€‚å› ä¸ºï¼ŒGo1.18 å¼€å§‹æ¥å£çš„å®šä¹‰å‘ç”Ÿäº†æ”¹å˜ï¼Œæ‰€ä»¥ `interface{}` çš„å®šä¹‰ä¹Ÿå‘ç”Ÿäº†ä¸€äº›å˜æ›´ï¼š

> ç©ºæ¥å£ä»£è¡¨äº†æ‰€æœ‰ç±»å‹çš„é›†åˆ

æ‰€ä»¥ï¼Œå¯¹äº Go1.18 ä¹‹åçš„ç©ºæ¥å£åº”è¯¥è¿™æ ·ç†è§£ï¼š

1. è™½ç„¶ç©ºæ¥å£å†…æ²¡æœ‰å†™å…¥ä»»ä½•çš„ç±»å‹ï¼Œä½†å®ƒä»£è¡¨çš„æ˜¯æ‰€æœ‰ç±»å‹çš„é›†åˆï¼Œè€Œéä¸€ä¸ª **ç©ºé›†**

2. ç±»å‹çº¦æŸä¸­æŒ‡å®š **ç©ºæ¥å£** çš„æ„æ€æ˜¯æŒ‡å®šäº†ä¸€ä¸ªåŒ…å«æ‰€æœ‰ç±»å‹çš„ç±»å‹é›†ï¼Œå¹¶ä¸æ˜¯ç±»å‹çº¦æŸé™å®šäº†åªèƒ½ä½¿ç”¨ **ç©ºæ¥å£** æ¥åšç±»å‹å½¢å‚

   ```go
   // ç©ºæ¥å£ä»£è¡¨æ‰€æœ‰ç±»å‹çš„é›†åˆã€‚å†™å…¥ç±»å‹çº¦æŸæ„å‘³ç€æ‰€æœ‰ç±»å‹éƒ½å¯æ‹¿æ¥åšç±»å‹å®å‚
   type Slice[T interface{}] []T

   var s1 Slice[int]    // æ­£ç¡®
   var s2 Slice[map[string]string]  // æ­£ç¡®
   var s3 Slice[chan int]  // æ­£ç¡®
   var s4 Slice[interface{}]  // æ­£ç¡®
   ```

å› ä¸ºç©ºæ¥å£æ˜¯ä¸€ä¸ªåŒ…å«äº†æ‰€æœ‰ç±»å‹çš„ç±»å‹é›†ï¼Œæ‰€ä»¥æˆ‘ä»¬ç»å¸¸ä¼šç”¨åˆ°å®ƒã€‚äºæ˜¯ï¼ŒGo1.18 å¼€å§‹æä¾›äº†ä¸€ä¸ªå’Œç©ºæ¥å£ `interface{}` ç­‰ä»·çš„æ–°å…³é”®è¯ `any` ï¼Œç”¨æ¥ä½¿ä»£ç æ›´ç®€å•ï¼š

```go
type Slice[T any] []T // ä»£ç ç­‰ä»·äº type Slice[T interface{}] []T
```

å®é™…ä¸Š `any` çš„å®šä¹‰å°±ä½äº Go è¯­è¨€çš„ `builtin.go` æ–‡ä»¶ä¸­ï¼ˆå‚è€ƒå¦‚ä¸‹ï¼‰ï¼Œ `any` å®é™…ä¸Šå°±æ˜¯ `interaface{}` çš„åˆ«å(alias)ï¼Œä¸¤è€…å®Œå…¨ç­‰ä»·

```go
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
```

æ‰€ä»¥ä» Go 1.18 å¼€å§‹ï¼Œæ‰€æœ‰å¯ä»¥ç”¨åˆ°ç©ºæ¥å£çš„åœ°æ–¹å…¶å®éƒ½å¯ä»¥ç›´æ¥æ›¿æ¢ä¸º anyï¼Œå¦‚ï¼š

```go
var s []any // ç­‰ä»·äº var s []interface{}
var m map[string]any // ç­‰ä»·äº var m map[string]interface{}

func MyPrint(value any){
    fmt.Println(value)
}
```

å¦‚æœä½ é«˜å…´çš„è¯ï¼Œé¡¹ç›®è¿ç§»åˆ° Go1.18 ä¹‹åå¯ä»¥ä½¿ç”¨ä¸‹é¢è¿™è¡Œå‘½ä»¤ç›´æ¥æŠŠæ•´ä¸ªé¡¹ç›®ä¸­çš„ç©ºæ¥å£å…¨éƒ½æ›¿æ¢æˆ anyã€‚å½“ç„¶å› ä¸ºå¹¶ä¸å¼ºåˆ¶ï¼Œæ‰€ä»¥åˆ°åº•æ˜¯ç”¨ `interface{}` è¿˜æ˜¯ `any` å…¨çœ‹è‡ªå·±å–œå¥½

```go
gofmt -w -r 'interface{} -> any' ./...
```

> ğŸ’¡ Go è¯­è¨€é¡¹ç›®ä¸­å°±æ›¾ç»æœ‰äººæå‡ºè¿‡æŠŠ Go è¯­è¨€ä¸­æ‰€æœ‰ interface{ }æ›¿æ¢æˆ any çš„ [issue](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fissues%2F49884)ï¼Œç„¶åå› ä¸ºå½±å“èŒƒå›´è¿‡å¤§è¿‡è€Œä¸”å½±å“å› ç´ ä¸ç¡®å®šï¼Œç†æ‰€å½“ç„¶è¢«é©³å›äº†

### 6.2.6 comparable(å¯æ¯”è¾ƒ) å’Œ å¯æ’åº(ordered)

å¯¹äºä¸€äº›æ•°æ®ç±»å‹ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç±»å‹çº¦æŸä¸­é™åˆ¶åªæ¥å—èƒ½ `!=` å’Œ `==` å¯¹æ¯”çš„ç±»å‹ï¼Œå¦‚ mapï¼š

```go
// é”™è¯¯ã€‚å› ä¸º map ä¸­é”®çš„ç±»å‹å¿…é¡»æ˜¯å¯è¿›è¡Œ != å’Œ == æ¯”è¾ƒçš„ç±»å‹
type MyMap[KEY any, VALUE any] map[KEY]VALUE
```

æ‰€ä»¥ Go ç›´æ¥å†…ç½®äº†ä¸€ä¸ªå« `comparable` çš„æ¥å£ï¼Œå®ƒä»£è¡¨äº†æ‰€æœ‰å¯ç”¨ `!=` ä»¥åŠ `==` å¯¹æ¯”çš„ç±»å‹ï¼š

```go
type MyMap[KEY comparable, VALUE any] map[KEY]VALUE // æ­£ç¡®
```

`comparable` æ¯”è¾ƒå®¹æ˜“å¼•èµ·è¯¯è§£çš„ä¸€ç‚¹æ˜¯å¾ˆå¤šäººå®¹æ˜“æŠŠä»–ä¸å¯æ’åºææ··æ·†ã€‚å¯æ¯”è¾ƒæŒ‡çš„æ˜¯ å¯ä»¥æ‰§è¡Œ `!=` `==` æ“ä½œçš„ç±»å‹ï¼Œå¹¶æ²¡ç¡®ä¿è¿™ä¸ªç±»å‹å¯ä»¥æ‰§è¡Œå¤§å°æ¯”è¾ƒï¼ˆ `>,<,<=,>=` ï¼‰ã€‚å¦‚ä¸‹ï¼š

```go
type OhMyStruct struct {
    a int
}

var a, b OhMyStruct

a == b // æ­£ç¡®ã€‚ç»“æ„ä½“å¯ä½¿ç”¨ == è¿›è¡Œæ¯”è¾ƒ
a != b // æ­£ç¡®

a > b // é”™è¯¯ã€‚ç»“æ„ä½“ä¸å¯æ¯”å¤§å°
```

è€Œå¯è¿›è¡Œå¤§å°æ¯”è¾ƒçš„ç±»å‹è¢«ç§°ä¸º `Orderd` ã€‚ç›®å‰ Go è¯­è¨€å¹¶æ²¡æœ‰åƒ `comparable` è¿™æ ·ç›´æ¥å†…ç½®å¯¹åº”çš„å…³é”®è¯ï¼Œæ‰€ä»¥æƒ³è¦çš„è¯éœ€è¦è‡ªå·±æ¥å®šä¹‰ç›¸å…³æ¥å£ï¼Œæ¯”å¦‚æˆ‘ä»¬å¯ä»¥å‚è€ƒ Go å®˜æ–¹åŒ…`golang.org/x/exp/constraints` å¦‚ä½•å®šä¹‰ï¼š

```go
// Ordered ä»£è¡¨æ‰€æœ‰å¯æ¯”å¤§å°æ’åºçš„ç±»å‹
type Ordered interface {
    Integer | Float | ~string
}

type Integer interface {
    Signed | Unsigned
}

type Signed interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

type Float interface {
    ~float32 | ~float64
}
```

ğŸ’¡ è¿™é‡Œè™½ç„¶å¯ä»¥ç›´æ¥ä½¿ç”¨å®˜æ–¹åŒ… [golang.org/x/exp/constraints](http://golang.org/x/exp/constraints) ï¼Œä½†å› ä¸ºè¿™ä¸ªåŒ…å±äºå®éªŒæ€§è´¨çš„ x åŒ…ï¼Œä»Šåå¯èƒ½ä¼šå‘ç”Ÿéå¸¸å¤§å˜åŠ¨ï¼Œæ‰€ä»¥å¹¶ä¸æ¨èç›´æ¥ä½¿ç”¨

## 6.3 æ¥å£ä¸¤ç§ç±»å‹

æˆ‘ä»¬æ¥ä¸‹æ¥å†è§‚å¯Ÿä¸€ä¸ªä¾‹å­ï¼Œè¿™ä¸ªä¾‹å­æ˜¯é˜è¿°æ¥å£æ˜¯ç±»å‹é›†æœ€å¥½çš„ä¾‹å­ï¼š

```go
type ReadWriter interface {
    ~string | ~[]rune

    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

æœ€å¼€å§‹çœ‹åˆ°è¿™ä¸€ä¾‹å­ä½ ä¸€å®šæœ‰ç‚¹æ‡µä¸å¤ªç†è§£å®ƒä»£è¡¨çš„æ„æ€ï¼Œä½†æ˜¯æ²¡å…³ç³»ï¼Œæˆ‘ä»¬ç”¨ç±»å‹é›†çš„æ¦‚å¿µå°±èƒ½æ¯”è¾ƒè½»æ¾ç†è§£è¿™ä¸ªæ¥å£çš„æ„æ€ï¼š

> æ¥å£ç±»å‹ ReadWriter ä»£è¡¨äº†ä¸€ä¸ªç±»å‹é›†åˆï¼Œæ‰€æœ‰ä»¥ string æˆ– []rune ä¸ºåº•å±‚ç±»å‹ï¼Œå¹¶ä¸”å®ç°äº† Read() Write() è¿™ä¸¤ä¸ªæ–¹æ³•çš„ç±»å‹éƒ½åœ¨ ReadWriter ä»£è¡¨çš„ç±»å‹é›†å½“ä¸­

å¦‚ä¸‹é¢ä»£ç ä¸­ï¼ŒStringReadWriter å­˜åœ¨äºæ¥å£ ReadWriter ä»£è¡¨çš„ç±»å‹é›†ä¸­ï¼Œè€Œ BytesReadWriter å› ä¸ºåº•å±‚ç±»å‹æ˜¯ []byteï¼ˆæ—¢ä¸æ˜¯ string ä¹Ÿæ˜¯ä¸[]runeï¼‰ ï¼Œæ‰€ä»¥å®ƒä¸å±äº ReadWriter ä»£è¡¨çš„ç±»å‹é›†

```go
// ç±»å‹ StringReadWriter å®ç°äº†æ¥å£ Readwriter
type StringReadWriter string

func (s StringReadWriter) Read(p []byte) (n int, err error) {
    // ...
}

func (s StringReadWriter) Write(p []byte) (n int, err error) {
 // ...
}

//  ç±»å‹BytesReadWriter æ²¡æœ‰å®ç°æ¥å£ Readwriter
type BytesReadWriter []byte

func (s BytesReadWriter) Read(p []byte) (n int, err error) {
 ...
}

func (s BytesReadWriter) Write(p []byte) (n int, err error) {
 ...
}
```

ä½ ä¸€å®šä¼šè¯´ï¼Œå•Šç­‰ç­‰ï¼Œè¿™æ¥å£ä¹Ÿå˜å¾—å¤ªå¤æ‚äº†æŠŠï¼Œé‚£æˆ‘å®šä¹‰ä¸€ä¸ª `ReadWriter` ç±»å‹çš„æ¥å£å˜é‡ï¼Œç„¶åæ¥å£å˜é‡èµ‹å€¼çš„æ—¶å€™ä¸å…‰è¦è€ƒè™‘åˆ°æ–¹æ³•çš„å®ç°ï¼Œè¿˜å¿…é¡»è€ƒè™‘åˆ°å…·ä½“åº•å±‚ç±»å‹ï¼Ÿå¿ƒæ™ºè´Ÿæ‹…ä¹Ÿå¤ªå¤§äº†å§ã€‚æ˜¯çš„ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ä¹Ÿä¸ºäº†ä¿æŒ Go è¯­è¨€çš„å…¼å®¹æ€§ï¼ŒGo1.18 å¼€å§‹å°†æ¥å£åˆ†ä¸ºäº†ä¸¤ç§ç±»å‹

- **åŸºæœ¬æ¥å£(Basic interface)**
- **ä¸€èˆ¬æ¥å£(General interface)**

### 6.3.1 åŸºæœ¬æ¥å£(Basic interface)

æ¥å£å®šä¹‰ä¸­å¦‚æœåªæœ‰æ–¹æ³•çš„è¯ï¼Œé‚£ä¹ˆè¿™ç§æ¥å£è¢«ç§°ä¸º**åŸºæœ¬æ¥å£(Basic interface)**ã€‚è¿™ç§æ¥å£å°±æ˜¯ Go1.18 ä¹‹å‰çš„æ¥å£ï¼Œç”¨æ³•ä¹ŸåŸºæœ¬å’Œ Go1.18 ä¹‹å‰ä¿æŒä¸€è‡´ã€‚åŸºæœ¬æ¥å£å¤§è‡´å¯ä»¥ç”¨äºå¦‚ä¸‹å‡ ä¸ªåœ°æ–¹ï¼š

- æœ€å¸¸ç”¨çš„ï¼Œå®šä¹‰æ¥å£å˜é‡å¹¶èµ‹å€¼

  ```go
  type MyError interface { // æ¥å£ä¸­åªæœ‰æ–¹æ³•ï¼Œæ‰€ä»¥æ˜¯åŸºæœ¬æ¥å£
      Error() string
  }

  // ç”¨æ³•å’Œ Go1.18ä¹‹å‰ä¿æŒä¸€è‡´
  var err MyError = fmt.Errorf("hello world")
  ```

- åŸºæœ¬æ¥å£å› ä¸ºä¹Ÿä»£è¡¨äº†ä¸€ä¸ªç±»å‹é›†ï¼Œæ‰€ä»¥ä¹Ÿå¯ç”¨åœ¨ç±»å‹çº¦æŸä¸­

  ```go
  // io.Reader å’Œ io.Writer éƒ½æ˜¯åŸºæœ¬æ¥å£ï¼Œä¹Ÿå¯ä»¥ç”¨åœ¨ç±»å‹çº¦æŸä¸­
  type MySlice[T io.Reader | io.Writer]  []Slice
  ```

### 6.3.2 ä¸€èˆ¬æ¥å£(General interface)

å¦‚æœæ¥å£å†…ä¸å…‰åªæœ‰æ–¹æ³•ï¼Œè¿˜æœ‰ç±»å‹çš„è¯ï¼Œè¿™ç§æ¥å£è¢«ç§°ä¸º **ä¸€èˆ¬æ¥å£(General interface)** ï¼Œå¦‚ä¸‹ä¾‹å­éƒ½æ˜¯ä¸€èˆ¬æ¥å£ï¼š

```go
type Uint interface { // æ¥å£ Uint ä¸­æœ‰ç±»å‹ï¼Œæ‰€ä»¥æ˜¯ä¸€èˆ¬æ¥å£
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type ReadWriter interface {  // ReadWriter æ¥å£æ—¢æœ‰æ–¹æ³•ä¹Ÿæœ‰ç±»å‹ï¼Œæ‰€ä»¥æ˜¯ä¸€èˆ¬æ¥å£
    ~string | ~[]rune

    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

**ä¸€èˆ¬æ¥å£ç±»å‹ä¸èƒ½ç”¨æ¥å®šä¹‰å˜é‡ï¼Œåªèƒ½ç”¨äºæ³›å‹çš„ç±»å‹çº¦æŸä¸­**ã€‚æ‰€ä»¥ä»¥ä¸‹çš„ç”¨æ³•æ˜¯é”™è¯¯çš„ï¼š

```go
type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

var uintInf Uint // é”™è¯¯ã€‚Uintæ˜¯ä¸€èˆ¬æ¥å£ï¼Œåªèƒ½ç”¨äºç±»å‹çº¦æŸï¼Œä¸å¾—ç”¨äºå˜é‡å®šä¹‰
```

è¿™ä¸€é™åˆ¶ä¿è¯äº†ä¸€èˆ¬æ¥å£çš„ä½¿ç”¨è¢«é™å®šåœ¨äº†æ³›å‹ä¹‹ä¸­ï¼Œä¸ä¼šå½±å“åˆ° Go1.18 ä¹‹å‰çš„ä»£ç ï¼ŒåŒæ—¶ä¹Ÿæå¤§å‡å°‘äº†ä¹¦å†™ä»£ç æ—¶çš„å¿ƒæ™ºè´Ÿæ‹…

## 6.4 æ³›å‹æ¥å£

æ‰€æœ‰ç±»å‹çš„å®šä¹‰ä¸­éƒ½å¯ä»¥ä½¿ç”¨ç±»å‹å½¢å‚ï¼Œæ‰€ä»¥æ¥å£å®šä¹‰è‡ªç„¶ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å‹å½¢å‚ï¼Œè§‚å¯Ÿä¸‹é¢è¿™ä¸¤ä¸ªä¾‹å­ï¼š

```go
type DataProcessor[T any] interface {
    Process(oriData T) (newData T)
    Save(data T) error
}

type DataProcessor2[T any] interface {
    int | ~struct{ Data interface{} }

    Process(data T) (newData T)
    Save(data T) error
}
```

å› ä¸ºå¼•å…¥äº†ç±»å‹å½¢å‚ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ªæ¥å£æ˜¯æ³›å‹ç±»å‹ã€‚**è€Œæ³›å‹ç±»å‹è¦ä½¿ç”¨çš„è¯å¿…é¡»ä¼ å…¥ç±»å‹å®å‚å®ä¾‹åŒ–æ‰æœ‰æ„ä¹‰**ã€‚æ‰€ä»¥æˆ‘ä»¬æ¥å°è¯•å®ä¾‹åŒ–ä¸€ä¸‹è¿™ä¸¤ä¸ªæ¥å£ã€‚å› ä¸º `T` çš„ç±»å‹çº¦æŸæ˜¯ anyï¼Œæ‰€ä»¥å¯ä»¥éšä¾¿æŒ‘ä¸€ä¸ªç±»å‹æ¥å½“å®å‚(æ¯”å¦‚ string)ï¼š

```go
DataProcessor[string]

// å®ä¾‹åŒ–ä¹‹åçš„æ¥å£å®šä¹‰ç›¸å½“äºå¦‚ä¸‹æ‰€ç¤ºï¼š
type DataProcessor[string] interface {
    Process(oriData string) (newData string)
    Save(data string) error
}
```

ç»è¿‡å®ä¾‹åŒ–ä¹‹åå°±å¥½ç†è§£äº†ï¼Œ `DataProcessor[string]` å› ä¸ºåªæœ‰æ–¹æ³•ï¼Œæ‰€ä»¥å®ƒå®é™…ä¸Šå°±æ˜¯ä¸ª **åŸºæœ¬æ¥å£(Basic interface)**ï¼Œè¿™ä¸ªæ¥å£åŒ…å«ä¸¤ä¸ªèƒ½å¤„ç† string ç±»å‹çš„æ–¹æ³•ã€‚åƒä¸‹é¢è¿™æ ·å®ç°äº†è¿™ä¸¤ä¸ªèƒ½å¤„ç† string ç±»å‹çš„æ–¹æ³•å°±ç®—å®ç°äº†è¿™ä¸ªæ¥å£ï¼š

```go
type CSVProcessor struct {
}

// æ³¨æ„ï¼Œæ–¹æ³•ä¸­ oriData ç­‰çš„ç±»å‹æ˜¯ string
func (c CSVProcessor) Process(oriData string) (newData string) {
    ....
}

func (c CSVProcessor) Save(oriData string) error {
    ...
}

// CSVProcessorå®ç°äº†æ¥å£ DataProcessor[string] ï¼Œæ‰€ä»¥å¯èµ‹å€¼
var processor DataProcessor[string] = CSVProcessor{}
processor.Process("name,age\nbob,12\njack,30")
processor.Save("name,age\nbob,13\njack,31")

// é”™è¯¯ã€‚CSVProcessoræ²¡æœ‰å®ç°æ¥å£ DataProcessor[int]
var processor2 DataProcessor[int] = CSVProcessor{}
```

å†ç”¨åŒæ ·çš„æ–¹æ³•å®ä¾‹åŒ– `DataProcessor2[T]` ï¼š

```go
DataProcessor2[string]

// å®ä¾‹åŒ–åçš„æ¥å£å®šä¹‰å¯è§†ä¸º
type DataProcessor2[T string] interface {
    int | ~struct{ Data interface{} }

    Process(data string) (newData string)
    Save(data string) error
}
```

`DataProcessor2[string]` å› ä¸ºå¸¦æœ‰ç±»å‹å¹¶é›†æ‰€ä»¥å®ƒæ˜¯ **ä¸€èˆ¬æ¥å£(General interface)**ï¼Œæ‰€ä»¥å®ä¾‹åŒ–ä¹‹åçš„è¿™ä¸ªæ¥å£ä»£è¡¨çš„æ„æ€æ˜¯ï¼š

1. åªæœ‰å®ç°äº† `Process(string) string` å’Œ `Save(string) error` è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå¹¶ä¸”ä»¥ `int` æˆ– `struct{ Data interface{} }` ä¸ºåº•å±‚ç±»å‹çš„ç±»å‹æ‰ç®—å®ç°äº†è¿™ä¸ªæ¥å£
2. **ä¸€èˆ¬æ¥å£(General interface)** ä¸èƒ½ç”¨äºå˜é‡å®šä¹‰åªèƒ½ç”¨äºç±»å‹çº¦æŸï¼Œæ‰€ä»¥æ¥å£ `DataProcessor2[string]` åªæ˜¯å®šä¹‰äº†ä¸€ä¸ªç”¨äºç±»å‹çº¦æŸçš„ç±»å‹é›†

```go
// XMLProcessor è™½ç„¶å®ç°äº†æ¥å£ DataProcessor2[string] çš„ä¸¤ä¸ªæ–¹æ³•ï¼Œä½†æ˜¯å› ä¸ºå®ƒçš„åº•å±‚ç±»å‹æ˜¯ []byteï¼Œæ‰€ä»¥ä¾æ—§æ˜¯æœªå®ç° DataProcessor2[string]
type XMLProcessor []byte

func (c XMLProcessor) Process(oriData string) (newData string) {

}

func (c XMLProcessor) Save(oriData string) error {

}

// JsonProcessor å®ç°äº†æ¥å£ DataProcessor2[string] çš„ä¸¤ä¸ªæ–¹æ³•ï¼ŒåŒæ—¶åº•å±‚ç±»å‹æ˜¯ struct{ Data interface{} }ã€‚æ‰€ä»¥å®ç°äº†æ¥å£ DataProcessor2[string]
type JsonProcessor struct {
    Data interface{}
}

func (c JsonProcessor) Process(oriData string) (newData string) {

}

func (c JsonProcessor) Save(oriData string) error {

}

// é”™è¯¯ã€‚DataProcessor2[string]æ˜¯ä¸€èˆ¬æ¥å£ä¸èƒ½ç”¨äºåˆ›å»ºå˜é‡
var processor DataProcessor2[string]

// æ­£ç¡®ï¼Œå®ä¾‹åŒ–ä¹‹åçš„ DataProcessor2[string] å¯ç”¨äºæ³›å‹çš„ç±»å‹çº¦æŸ
type ProcessorList[T DataProcessor2[string]] []T

// æ­£ç¡®ï¼Œæ¥å£å¯ä»¥å¹¶å…¥å…¶ä»–æ¥å£
type StringProcessor interface {
    DataProcessor2[string]

    PrintString()
}

// é”™è¯¯ï¼Œå¸¦æ–¹æ³•çš„ä¸€èˆ¬æ¥å£ä¸èƒ½ä½œä¸ºç±»å‹å¹¶é›†çš„æˆå‘˜(å‚è€ƒ6.5 æ¥å£å®šä¹‰çš„ç§ç§é™åˆ¶è§„åˆ™
type StringProcessor interface {
    DataProcessor2[string] | DataProcessor2[[]byte]

    PrintString()
}
```

## 6.5 æ¥å£å®šä¹‰çš„ç§ç§é™åˆ¶è§„åˆ™

Go1.18 ä»å¼€å§‹ï¼Œåœ¨å®šä¹‰ç±»å‹é›†(æ¥å£)çš„æ—¶å€™å¢åŠ äº†éå¸¸å¤šååˆ†çç¢çš„é™åˆ¶è§„åˆ™ï¼Œå…¶ä¸­å¾ˆå¤šè§„åˆ™éƒ½åœ¨ä¹‹å‰çš„å†…å®¹ä¸­ä»‹ç»è¿‡äº†ï¼Œä½†å‰©ä¸‹è¿˜æœ‰ä¸€äº›è§„åˆ™å› ä¸ºæ‰¾ä¸åˆ°å¥½çš„åœ°æ–¹ä»‹ç»ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œç»Ÿä¸€ä»‹ç»ä¸‹ï¼š

1. ç”¨ `|` è¿æ¥å¤šä¸ªç±»å‹çš„æ—¶å€™ï¼Œç±»å‹ä¹‹é—´ä¸èƒ½æœ‰ç›¸äº¤çš„éƒ¨åˆ†(å³å¿…é¡»æ˜¯ä¸äº¤é›†):

   ```go
   type MyInt int

   // é”™è¯¯ï¼ŒMyIntçš„åº•å±‚ç±»å‹æ˜¯int,å’Œ ~int æœ‰ç›¸äº¤çš„éƒ¨åˆ†
   type _ interface {
       ~int | MyInt
   }
   ```

   ä½†æ˜¯ç›¸äº¤çš„ç±»å‹ä¸­æ˜¯æ¥å£çš„è¯ï¼Œåˆ™ä¸å—è¿™ä¸€é™åˆ¶ï¼š

   ```go
   type MyInt int

   type _ interface {
       ~int | interface{ MyInt }  // æ­£ç¡®
   }

   type _ interface {
       interface{ ~int } | MyInt // ä¹Ÿæ­£ç¡®
   }

   type _ interface {
       interface{ ~int } | interface{ MyInt }  // ä¹Ÿæ­£ç¡®
   }
   ```

2. ç±»å‹çš„å¹¶é›†ä¸­ä¸èƒ½æœ‰ç±»å‹å½¢å‚

   ```go
   type MyInf[T ~int | ~string] interface {
       ~float32 | T  // é”™è¯¯ã€‚Tæ˜¯ç±»å‹å½¢å‚
   }

   type MyInf2[T ~int | ~string] interface {
       T  // é”™è¯¯
   }
   ```

3. æ¥å£ä¸èƒ½ç›´æ¥æˆ–é—´æ¥åœ°å¹¶å…¥è‡ªå·±

   ```go
   type Bad interface {
       Bad // é”™è¯¯ï¼Œæ¥å£ä¸èƒ½ç›´æ¥å¹¶å…¥è‡ªå·±
   }

   type Bad2 interface {
       Bad1
   }
   type Bad1 interface {
       Bad2 // é”™è¯¯ï¼Œæ¥å£Bad1é€šè¿‡Bad2é—´æ¥å¹¶å…¥äº†è‡ªå·±
   }

   type Bad3 interface {
       ~int | ~string | Bad3 // é”™è¯¯ï¼Œé€šè¿‡ç±»å‹çš„å¹¶é›†å¹¶å…¥äº†è‡ªå·±
   }
   ```

4. æ¥å£çš„å¹¶é›†æˆå‘˜ä¸ªæ•°å¤§äºä¸€çš„æ—¶å€™ä¸èƒ½ç›´æ¥æˆ–é—´æ¥å¹¶å…¥ `comparable` æ¥å£

   ```jsx
   type OK interface {
       comparable // æ­£ç¡®ã€‚åªæœ‰ä¸€ä¸ªç±»å‹çš„æ—¶å€™å¯ä»¥ä½¿ç”¨ comparable
   }

   type Bad1 interface {
       []int | comparable // é”™è¯¯ï¼Œç±»å‹å¹¶é›†ä¸èƒ½ç›´æ¥å¹¶å…¥ comparable æ¥å£
   }

   type CmpInf interface {
       comparable
   }
   type Bad2 interface {
       chan int | CmpInf  // é”™è¯¯ï¼Œç±»å‹å¹¶é›†é€šè¿‡ CmpInf é—´æ¥å¹¶å…¥äº†comparable
   }
   type Bad3 interface {
       chan int | interface{comparable}  // ç†æ‰€å½“ç„¶ï¼Œè¿™æ ·ä¹Ÿæ˜¯ä¸è¡Œçš„
   }
   ```

5. å¸¦æ–¹æ³•çš„æ¥å£(æ— è®ºæ˜¯åŸºæœ¬æ¥å£è¿˜æ˜¯ä¸€èˆ¬æ¥å£)ï¼Œéƒ½ä¸èƒ½å†™å…¥æ¥å£çš„å¹¶é›†ä¸­ï¼š

   ```go
   type _ interface {
       ~int | ~string | error // é”™è¯¯ï¼Œerroræ˜¯å¸¦æ–¹æ³•çš„æ¥å£(ä¸€èˆ¬æ¥å£) ä¸èƒ½å†™å…¥å¹¶é›†ä¸­
   }

   type DataProcessor[T any] interface {
       ~string | ~[]byte

       Process(data T) (newData T)
       Save(data T) error
   }

   // é”™è¯¯ï¼Œå®ä¾‹åŒ–ä¹‹åçš„ DataProcessor[string] æ˜¯å¸¦æ–¹æ³•çš„ä¸€èˆ¬æ¥å£ï¼Œä¸èƒ½å†™å…¥ç±»å‹å¹¶é›†
   type _ interface {
       ~int | ~string | DataProcessor[string]
   }

   type Bad[T any] interface {
       ~int | ~string | DataProcessor[T]  // ä¹Ÿä¸è¡Œ
   }
   ```

# [Golang] æ³›å‹çš„ä½¿ç”¨

## å‰è¨€

**æ³›å‹** æ˜¯ä»€ä¹ˆ? å…¶å®è¿™ä¸ªé—®é¢˜å¯¹äºå­¦è¿‡ **C++** çš„åŒå­¦æ¥è¯´ä¸é™Œç”Ÿå°±æ˜¯æ¨¡ç‰ˆå˜›, åœ¨è¿è¡Œæ—¶æ‰ç¡®å®šç±»å‹å˜›. ç¡®å®è¿™ä¸¤å¥è¯å°±åŸºæœ¬èƒ½è§£ææ¸…æ¥š, ä½†åƒä¸€äº›åªæ¥è§¦è¿‡ **Python** çš„åŒå­¦æ¥è¯´ç¡®å®æ²¡å¬è¯´è¿‡, æ¯•ç«Ÿå°±æ˜¯ **Python** æ˜¯åŠ¨æ€ç¼–è¯‘çš„ä¸éœ€è¦æ³›å‹.

å¯¹äº **Golang** æ¥è¯´, æ³›å‹åœ¨ç‰ºç‰²ä¸€ç‚¹æ€§èƒ½çš„å‰æä¸‹èƒ½å¤§å¤§é™ä½å¯¹é€šç”¨ä»£ç çš„ç¼–ç éš¾åº¦, ä¸ç„¶åªèƒ½ä¹–ä¹–çš„ç”¨åå°„è§£å†³é—®é¢˜, æˆ–è€…å¯¹ä¸åŒç±»å‹å¤šå¤åˆ¶å‡ºå‡ ä»½ä»£ç ;

æœ¬æ–‡æ²¡æœ‰å¯¹æ³›å‹è¿›è¡Œå…¥é—¨ä»‹ç», éœ€è¦çš„è¯·è·³è½¬ [æ³›å‹åˆè¯†](https://juejin.cn/post/7116817920209977351#heading-18)

## æ³›å‹å®è·µ

### å…³é”®å­—å‚æ•°

- ä¼—æ‰€å‘¨çŸ¥å¾ˆå¤šè¯­è¨€çš„ function ä¸­éƒ½æ”¯æŒ key=word å…³é”®å­—å‚æ•°, ä½† golang æ˜¯ä¸æ”¯æŒçš„, æˆ‘ä»¬å¯ä»¥åˆ©ç”¨æ³›å‹å»ç®€å•çš„å®ç°.

  ```golang
  func DefaultKeyWordParams[D any](defVal D, params ...D) D {
          if len(params) == 0 {
                  return defVal
          }
          return params[0]
  }


  func test(category ...string) {
      // ä¸å¡«å†™åˆ™è¿”å›é»˜è®¤å€¼
      realCategory := DefaultKeyWordParams[string]("AGroup", category...)
      fmt.Println(realCategory)
  }

  func main () {
       test()
  }
  ```

### å¿«é€Ÿæ’åº

```
UpdateAt: 2023-02-22
```

- å®ç°ä¸€ä¸ªå¯è¿›è¡Œæ§åˆ¶åè½¬çš„é€šç”¨ç±»å‹å¿«é€Ÿæ’åº, è§£å†³ä¸€ä¸‹åŸç”Ÿçš„ sort åŒ…è¿›è¡Œç±»å‹å®šä¹‰çš„ç¹ç.

  ```golang
  // QuickSort é€šç”¨å¿«é€Ÿæ’åº
  func QuickSort[T any](arr []T, compareFn func(a, b T) bool) {
          if len(arr) < 2 {
                  return
          }

          pivot := arr[0]
          left := 1
          right := len(arr) - 1

          for left <= right {
                  if compareFn(arr[left], pivot) {
                          left++
                  } else if compareFn(pivot, arr[right]) {
                          right--
                  } else {
                          arr[left], arr[right] = arr[right], arr[left]
                  }
          }

          arr[0], arr[right] = arr[right], arr[0]

          QuickSort(arr[:right], compareFn)
          QuickSort(arr[right+1:], compareFn)
  }
  ```

- æµ‹è¯•ç”¨ä¾‹

  ```golang
  func TestQuickSort(t *testing.T) {
          nums := []int{9, 3, 1, 7, 4, 8, 6, 2, 5}
          fmt.Println("Unsorted:", nums)

          QuickSort[int](nums, func(a, b int) bool {
                  return a < b
          })
          fmt.Println("Sorted:  ", nums)

          strs := []string{"orange", "apple", "banana", "kiwi", "grape"}
          fmt.Println("Unsorted:", strs)

          QuickSort[string](strs, func(a, b string) bool {
                  return len(a) < len(b)
          })
          fmt.Println("Sorted:  ", strs)
  }
  ```

### å»é‡å¤

- è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å®ç°, å¤æ‚ç‚¹å¯ä»¥é€šè¿‡å›è°ƒ + æ³›å‹æ¥å®ç°;

  ```golang
  func RemoveDuplicate[T string | int | float64](duplicateSlice []T) []T {
          set := map[T]interface{}{}
          res := []T{}
          for _, item := range duplicateSlice {
                  _, ok := set[item]
                  if !ok {
                          res = append(res, item)
                          set[item] = nil
                  }
          }
          return res
  }

  func main() {
          fmt.Println(RemoveDuplicate[string]([]string{"a", "c", "a"}))
          fmt.Println(RemoveDuplicate[int]([]int{1, 2, 1, 1, 1}))
  }
  ```

- é€šè¿‡æ§åˆ¶åè½¬å®ç°é€šç”¨çš„å»é‡å¤æ–¹æ³•, æ”¯æŒä»»æ„ç±»å‹;

  ```golang
  type Student struct {
          Name string
          Age  int
  }

  func NewStudent(name string, age int) *Student {
          return &Student{Name: name, Age: age}
  }

  func DefaultFilter(item interface{}) (uniqueKey interface{}) {
          return item.(*Student).Name
  }

  func RemoveDuplicateWithFilter[T comparable](compareSlice []T, filterFunc func(item interface{}) (key interface{})) []T {
          set := map[interface{}]interface{}{}
          res := []T{}
          for _, item := range compareSlice {
                  i := filterFunc(item)
                  _, ok := set[i]
                  if !ok {
                          res = append(res, item)
                          set[i] = nil
                  }
          }
          return res
  }

  func main() {
          s := []*Student{
                  NewStudent("a", 1),
                  NewStudent("a", 1),
                  NewStudent("b", 2),
                  NewStudent("b", 2),
          }
          l := RemoveDuplicateWithFilter[*Student](s, DefaultFilter)
          for _, i := range l {
                  fmt.Println(i.Name, i.Age)
          }
  }
  ```

### è”åˆçº¦æŸç±»å‹

- è¯¥ä¾‹å­åªæ˜¯ä¸€ä¸ªæ¼”ç¤º, æ²¡æœ‰å®é™…æ•ˆæœ

  ```golang
  type ID interface {
      int | string
  }

  // å†™æ³•  [T ID, D string] == [T int | string, D string]
  type UserModel[T ID, D string] struct {
          Id   T
          Name D
  }

  func NewUserModel[A ID, D string](id A, name D) *UserModel[A, D] {
          return &UserModel[A, D]{Id: id, Name: name}
  }

  func main() {
          fmt.Println(NewUserModel[int, string](10, "hello"))
          fmt.Println(NewUserModel[string, string]("10", "hello"))
  }
  ```

### åˆ†é¡µ

- è¿™æ˜¯ä¸€æ®µçº¿ä¸Šåœ¨ä½¿ç”¨çš„åˆ†é¡µä»£ç , å½“æ— æ³•ä½¿ç”¨å¤–éƒ¨å­˜å‚¨å™¨è¿›è¡Œåˆ†é¡µæ—¶ç›´æ¥ä½¿ç”¨è¯¥å¯¹è±¡è¿›è¡Œåˆ†é¡µ, æ”¯æŒä»»æ„ç±»å‹;

  ```golang
  type KeepItem bool

  // è‹¥éœ€è¦ä¿ç•™çš„item åˆ™è¿”å›true å³å¯
  type FilterFunc func(item interface{}) KeepItem

  type PageList[T any] struct {
          Total int `json:"total"`
          Page  int `json:"page"`
          Size  int `json:"size"`
          List  []T `json:"list"`
  }

  type Pager[T any] struct {
          limit   int
          offset  int
          total   int
          pageCnt int
          list    []T
  }

  func NewPager[T any](list []T) *Pager[T] {
          return &Pager[T]{
                  limit:  10,
                  offset: 1,
                  total:  len(list),
                  list:   list,
          }
  }

  func (this *Pager[T]) Filter(filterFn FilterFunc) *Pager[T] {
          tmpList := []T{}
          for _, item := range this.list {
                  if filterFn(&item) {
                          tmpList = append(tmpList, item)
                  }
          }
          this.list = tmpList
          this.total = len(tmpList)
          return this
  }

  func (this *Pager[T]) Offset(c int) *Pager[T] {
          this.offset = c
          return this
  }

  func (this *Pager[T]) Limit(c int) *Pager[T] {
          this.limit = c
          return this
  }

  func (this *Pager[T]) List() []T {
          // é¡µç 
          if this.offset <= 0 {
                  this.offset = 1
          }
          // size
          if this.limit > this.total {
                  this.limit = this.total
          }
          // æ€»é¡µæ•°
          this.pageCnt = int(math.Ceil(float64(this.total) / float64(this.limit)))
          if this.offset > this.pageCnt {
                  return []T{}
          }
          startIdx := (this.offset - 1) * this.limit
          endIdx := startIdx + this.limit

          if endIdx > this.total {
                  endIdx = this.total
          }

          return this.list[startIdx:endIdx]
  }

  func (this *Pager[T]) Output() *PageList[T] {

          return &PageList[T]{
                  Total: this.total,
                  Page:  this.offset,
                  Size:  this.limit,
                  List:  this.list,
          }
  }

  // test
  func main () {
  	page := NewPager[int]([]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
          list := page.Offset(1).Limit(3).Filter(func(item interface{}) KeepItem {
  	if *item.(*int)%2 == 1 {
  		return true
  	}
  	return false
          }).List()
          fmt.Println(list)
  }

  ```

### é€šç”¨åˆå§‹åŒ–æ¨¡å‹

- å¯ä»¥è§£å†³åœ¨å¤šæ€ä¸‹ä½¿ç”¨åŒä¸€ä¸ªåˆå§‹åŒ–å‡½æ•°è¿›è¡Œå¯¹è±¡åˆå§‹åŒ–, å†™æ³•ä¸Šæœ‰ç‚¹ç»•å¤§å®¶è‡ªè¡Œå¤šå®éªŒå‡ æ¬¡å°±èƒ½æ˜ç™½.

  ```golang
  type ModelObj interface {
          User | Product
  }

  type User struct {
          Uid int
  }

  func (this *User) SetId(id int) {
          this.Uid = id
  }

  type Product struct {
          Pid int
  }

  func (this *Product) SetId(id int) {
          this.Pid = id
  }

  // TrimModelObj æ˜¯ä¸€ä¸ªåŠ¨æ€ç±»å‹çš„ Interface, ç”±Må†³å®šå½“å‰Interfaceçš„æœ€ç»ˆç±»å‹
  type TrimModelObj[M ModelObj] interface {
          *M
          SetId(id int)
  }

  // TrimModelObj[Model] ç”±ç¬¬äºŒä¸ªå‚æ•°å†³å®šå½“å‰çš„åŠ¨æ€ç±»å‹ï¼›
  // NewModelObj[*User, User](32) å¦‚ Model æ˜¯ User ç±»å‹, æœ€ç»ˆ TrimModelObj == *Userï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸º Trim ä¼ é€’ *User
  func NewModelObj[Trim TrimModelObj[Model], Model ModelObj](id int) Trim {
          m := new(Model)
          t := Trim(m)
          fmt.Printf("%p \n", m)
          // ç±»å‹è½¬æ¢æˆæŒ‡å®šçš„*Model
          t.SetId(id)
          return t
  }


  func main() {
          // new user model object
          user := NewModelObj[*User, User](32)
          fmt.Printf("%p \n", user)
          fmt.Printf("%T \n", user)
          fmt.Println(user.Uid)

          // new product model object
          prod := NewModelObj[*Product, Product](18)
          fmt.Printf("%p \n", prod)
          fmt.Printf("%T \n", prod)
          fmt.Println(prod.Pid)
  }
  ```

### ä¸€å †ç±»å‹è½¬æ¢ Convertor

- `UpdateAt: 2023-03-20`

  ```golang
  package convertor

  import (
          "encoding/json"
          "fmt"
  )

  // InterfaceToSlice interfaceç±»å‹è½¬slice
  func InterfaceToSlice[T any](i interface{}) ([]T, error) {
          s := make([]T, 0)
          marshal, err := json.Marshal(i)
          if err != nil {
                  return nil, fmt.Errorf("convert iterface to slice error. %s", err.Error())
          }
          if err := json.Unmarshal(marshal, &s); err != nil {
                  return nil, fmt.Errorf("convert iterface to slice error. %s", err.Error())
          }
          return s, nil
  }

  // InterfaceToStruct interface  ç±»å‹è½¬ struct
  func InterfaceToStruct[T any](i interface{}) (*T, error) {
          marshal, err := json.Marshal(i)
          if err != nil {
                  return nil, fmt.Errorf("convert interface to struct error. %s", err.Error())
          }

          t := new(T)
          if err := json.Unmarshal(marshal, t); err != nil {
                  return nil, fmt.Errorf("convert interface to struct error. %s", err.Error())
          }
          return t, nil
  }

  // InterfaceToMap interface è½¬ map
  func InterfaceToMap[K comparable, V any](i interface{}) (map[K]V, error) {
          marshal, err := json.Marshal(i)
          if err != nil {
                  return nil, fmt.Errorf("convert interface to map error. %s", err.Error())
          }
          m := make(map[K]V, 0)
          if err := json.Unmarshal(marshal, &m); err != nil {
                  return nil, fmt.Errorf("convert interface to map error. %s", err.Error())
          }
          return m, nil
  }

  // MapToStruct map to struct
  func MapToStruct[T any](m map[string]interface{}) (*T, error) {
          t := new(T)
          marshal, err := json.Marshal(m)
          if err != nil {
                  return nil, fmt.Errorf("convert map to struct error. %s", err.Error())
          }
          if err := json.Unmarshal(marshal, &t); err != nil {
                  return nil, fmt.Errorf("convert map to struct error. %s", err.Error())
          }
          return t, nil

  }

  // StructToMap struct to map
  func StructToMap[K comparable, V any](s interface{}) (map[K]V, error) {
          m := make(map[K]V, 0)
          marshal, err := json.Marshal(s)
          if err != nil {
                  return nil, fmt.Errorf("convert struct to map error. %s", err.Error())
          }
          if err := json.Unmarshal(marshal, &m); err != nil {
                  return nil, fmt.Errorf("convert struct to map error. %s", err.Error())
          }
          return m, nil
  }
  ```
