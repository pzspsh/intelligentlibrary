# Go的内置函数
```bash
make 第一个参数是类型，而不是值；第二个参数是可选（变长）参数，整型类型的值，返回值是该类型的值本身。
需要注意的是，第一个参数不同（不同类型），第二个参数的含义不同。

slice 第一个参数是切片类型，第二个参数的含义是指定切片的长度。如果没有传递第三个参数（整型类型的值），切片的容量等同于切片的长度，否则，切片的容量等同于第三个参数的值，需要注意的是，切片的容量必须不小于切片的长度。
map 分配一个有足够空间可以容纳指定数量元素的空映射，第二个参数可以省略，如果省略第二个参数，将分配一个起始值 0。
channel 指定缓冲区大小，初始化通道，如果第二个参数省略，或指定值为 0，该通道将被初始化为一个无缓冲通道。
内置函数 new：

内置函数 new 也可以分配内存，与 make 的区别是，它仅分配内存，而未初始化。
和 make 相同，第一个参数是类型，而不是值；
和 make 不同，返回值是新分配的类型零值的指针。

内置函数 complex：
内置函数 complex 将两个浮点型的值构造为一个复合类型的值，需要注意的是，实部和虚部必须是相同类型，即都是 float32 或 float64。

返回值是对应的复合类型，即 complex64 对应 float32 或 complex128 对应 float64。

内置函数 real：
内置函数 real 用于返回复合类型的值的实部，返回值是对应的浮点数类型。
内置函数 imag：
内置函数 imag 用于返回复合类型的值的虚部，返回值是对应的浮点数类型。
注意：complex、real 和 imag 三个内置函数，一般不常用，读者朋友们只需简单了解即可。

内置函数 close：
内置函数 close 关闭通道，被关闭的通道必须是一个双向通道或仅支持发送的单向通道。
并且 close 应该由发送者执行，结果是在最后一个发送的值被接收后，关闭该通道。
通道被关闭后，任何该通道的接收者将返回成功而不会阻塞，接收者得到的返回值是该通道的类型零值和一个布尔类型的零值 false。
需要注意的是，不仅是关闭通道会返回 false，空通道也会返回 false。

内置函数 panic：
内置函数 panic 停止当前 goroutine 正常执行，当一个函数 F 调用 panic 时，该函数 F 立即停止正常执行。
该函数 F 通过 defer 延迟调用的任意函数，仍然会执行，并将执行结果返回给 F 调用者。
对于 F 的调用者 F2，调用 F 也会像调用 panic，停止 F2 的执行，并运行 F2 通过 defer 延迟调用的任意函数。以此类推，一直持续到当前 goroutine 中的所有函数都以相反的顺序停止运行。

此时，程序以非 0 退出代码终止运行。
以上终止程序运行的序列称为“恐慌”，可以通过接下来我们要介绍的内置函数 recover 进行控制。
内置函数 recover：
内置函数 recover 允许程序管理“恐慌”的 goroutine 的行为。
可以在 defer 中调用 recover 恢复正常执行来停止“恐慌”，并且检索导致“恐慌”的错误。
但是，如果在 defer 之外调用 recover，它不会恢复正常执行来停止“恐慌”。此种情况，recover 的返回值是 nil。此外，当前执行 recover 的 goroutine 未“恐慌”，或调用 panic(nil) 时，recover 的返回值也是 nil。
因此，我们可以通过 recover 的返回值，判断当前 goroutine 是否“恐慌”。
注意：此处讲的在 defer 中调用 recover，是指在 defer 本身中，而不是任何被 defer 调用的函数中。

内置函数 print：
内置函数 print 可以通过指定格式来格式化其参数，并将结果输出。
内置函数 println：
内置函数 println 可以通过指定格式来格式化其参数，并将结果输出。与 print 的区别是，参数之间会添加空格，末尾会添加换行符。
注意：print 和 println 与标准库 fmt 中的 fmt.Print() 和 fmt.Println() 的区别是，前者是标准错误输出，后者是标准输出。在 Go 语言开发中，官方推荐使用标准库 fmt 包，感兴趣的读者朋友们可以查阅相关资料进一步了解。


总结
本文我们介绍 Go 语言的内置函数，读者朋友们需要重点掌握的内置函数是 len、cap、make、new、append、copy、delete、close、panic 和 recover。
```